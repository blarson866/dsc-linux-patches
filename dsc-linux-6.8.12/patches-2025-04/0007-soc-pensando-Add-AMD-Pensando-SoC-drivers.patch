From cc4f8ab16a48b426026c466b4c1bc17a1224a75f Mon Sep 17 00:00:00 2001
From: Brad Larson <bradley.larson@amd.com>
Date: Wed, 2 Apr 2025 11:48:51 -0700
Subject: [PATCH 07/17] soc/pensando: Add AMD Pensando SoC drivers

Support for Elba, Giglio and Salina SoC based boards

Signed-off-by: Brad Larson <bradley.larson@amd.com>
---
 drivers/soc/Kconfig                    |   1 +
 drivers/soc/Makefile                   |   1 +
 drivers/soc/pensando/Kconfig           |  91 +++
 drivers/soc/pensando/Makefile          |  17 +
 drivers/soc/pensando/bsm_dev.h         |  24 +
 drivers/soc/pensando/cap_bsm.c         | 159 +++++
 drivers/soc/pensando/cap_crash.c       | 157 +++++
 drivers/soc/pensando/cap_mem.c         | 519 ++++++++++++++
 drivers/soc/pensando/cap_pcie.c        | 456 +++++++++++++
 drivers/soc/pensando/cap_pcie_capri.h  |  44 ++
 drivers/soc/pensando/cap_pcie_common.h |  52 ++
 drivers/soc/pensando/cap_pcie_elba.h   |  13 +
 drivers/soc/pensando/cap_pcie_giglio.h |  13 +
 drivers/soc/pensando/cap_pcie_salina.h |  55 ++
 drivers/soc/pensando/cap_reboot.c      | 110 +++
 drivers/soc/pensando/cap_reboot.h      |  12 +
 drivers/soc/pensando/cap_rstcause.c    | 217 ++++++
 drivers/soc/pensando/cap_rstcause.h    |  15 +
 drivers/soc/pensando/cap_soc.c         |  32 +
 drivers/soc/pensando/cap_tracepoint.h  | 175 +++++
 drivers/soc/pensando/capmem_dev.h      |  37 +
 drivers/soc/pensando/cmn_pmu_irq.c     | 106 +++
 drivers/soc/pensando/kpci_constants.h  |  41 ++
 drivers/soc/pensando/kpcimgr.c         | 902 +++++++++++++++++++++++++
 drivers/soc/pensando/kpcimgr_api.h     | 174 +++++
 drivers/soc/pensando/kpcimgr_sysfs.c   | 277 ++++++++
 drivers/soc/pensando/penfw.h           |  59 ++
 drivers/soc/pensando/penfw_drv.c       | 159 +++++
 drivers/soc/pensando/penfw_smc.c       | 212 ++++++
 drivers/soc/pensando/penfw_sysfs.c     | 443 ++++++++++++
 drivers/soc/pensando/penfw_sysfs.h     |  11 +
 drivers/soc/pensando/penpcie_dev.h     |  26 +
 drivers/soc/pensando/sbus.c            | 303 +++++++++
 33 files changed, 4913 insertions(+)
 create mode 100644 drivers/soc/pensando/Kconfig
 create mode 100644 drivers/soc/pensando/Makefile
 create mode 100644 drivers/soc/pensando/bsm_dev.h
 create mode 100644 drivers/soc/pensando/cap_bsm.c
 create mode 100644 drivers/soc/pensando/cap_crash.c
 create mode 100644 drivers/soc/pensando/cap_mem.c
 create mode 100644 drivers/soc/pensando/cap_pcie.c
 create mode 100644 drivers/soc/pensando/cap_pcie_capri.h
 create mode 100644 drivers/soc/pensando/cap_pcie_common.h
 create mode 100644 drivers/soc/pensando/cap_pcie_elba.h
 create mode 100644 drivers/soc/pensando/cap_pcie_giglio.h
 create mode 100644 drivers/soc/pensando/cap_pcie_salina.h
 create mode 100644 drivers/soc/pensando/cap_reboot.c
 create mode 100644 drivers/soc/pensando/cap_reboot.h
 create mode 100644 drivers/soc/pensando/cap_rstcause.c
 create mode 100644 drivers/soc/pensando/cap_rstcause.h
 create mode 100644 drivers/soc/pensando/cap_soc.c
 create mode 100644 drivers/soc/pensando/cap_tracepoint.h
 create mode 100644 drivers/soc/pensando/capmem_dev.h
 create mode 100644 drivers/soc/pensando/cmn_pmu_irq.c
 create mode 100644 drivers/soc/pensando/kpci_constants.h
 create mode 100644 drivers/soc/pensando/kpcimgr.c
 create mode 100644 drivers/soc/pensando/kpcimgr_api.h
 create mode 100644 drivers/soc/pensando/kpcimgr_sysfs.c
 create mode 100644 drivers/soc/pensando/penfw.h
 create mode 100644 drivers/soc/pensando/penfw_drv.c
 create mode 100644 drivers/soc/pensando/penfw_smc.c
 create mode 100644 drivers/soc/pensando/penfw_sysfs.c
 create mode 100644 drivers/soc/pensando/penfw_sysfs.h
 create mode 100644 drivers/soc/pensando/penpcie_dev.h
 create mode 100644 drivers/soc/pensando/sbus.c

diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index 5d924e946507..b91c529a05ce 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -17,6 +17,7 @@ source "drivers/soc/loongson/Kconfig"
 source "drivers/soc/mediatek/Kconfig"
 source "drivers/soc/microchip/Kconfig"
 source "drivers/soc/nuvoton/Kconfig"
+source "drivers/soc/pensando/Kconfig"
 source "drivers/soc/pxa/Kconfig"
 source "drivers/soc/qcom/Kconfig"
 source "drivers/soc/renesas/Kconfig"
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index ba8f5b5460e1..bd1165cceb47 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -22,6 +22,7 @@ obj-y				+= loongson/
 obj-y				+= mediatek/
 obj-y				+= microchip/
 obj-y				+= nuvoton/
+obj-$(CONFIG_ARCH_PENSANDO)	+= pensando/
 obj-y				+= pxa/
 obj-y				+= amlogic/
 obj-y				+= qcom/
diff --git a/drivers/soc/pensando/Kconfig b/drivers/soc/pensando/Kconfig
new file mode 100644
index 000000000000..a56135d191c3
--- /dev/null
+++ b/drivers/soc/pensando/Kconfig
@@ -0,0 +1,91 @@
+if ARCH_PENSANDO
+
+menu "Pensando SoC drivers"
+
+choice
+    prompt "SoC Select"
+    default ARCH_PENSANDO_ELBA_SOC
+
+config ARCH_PENSANDO_ELBA_SOC
+	bool "Elba SoC"
+	select DMA_OPS
+	select REGMAP_SPI
+	help
+	  Support for the Pensando Elba SoC
+
+config ARCH_PENSANDO_GIGLIO_SOC
+	bool "Giglio SoC"
+	help
+	  Support for the Pensando Giglio SoC
+
+config ARCH_PENSANDO_SALINA_SOC
+	bool "Salina SoC"
+	select DMA_OPS
+	help
+	  Support for the Pensando Salina SoC
+endchoice
+
+config PENSANDO_SOC_CAPMEM
+	tristate "/dev/capmem driver for the Pensando SoCs"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC memory driver
+
+config PENSANDO_SOC_CAPMEM_HUGEPAGE
+	tristate "Enable hugepage support in capmem"
+	select TRANSPARENT_HUGEPAGE
+	default n
+	help
+	  Support for Huge pages in Pensando SoC memory driver
+
+config PENSANDO_SOC_PCIE
+	tristate "PCIe driver for Pensando SoCs"
+	depends on OF
+	default y
+	help
+	  Provide a PCIe driver for pciemgr kernel assist
+
+config PENSANDO_SOC_RSTCAUSE
+	tristate "Pensando reset cause driver"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC reset cause driver
+
+config PENSANDO_SOC_CRASH
+	tristate "Pensando crash driver"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC crash driver
+
+config PENSANDO_SOC_BSM
+	bool "Pensando SoC Boot State Machine"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC boot state machine driver
+
+config PENSANDO_SOC_BSM_ENABLE
+	bool "Enable the Boot State Machine in the kernel"
+        depends on PENSANDO_SOC_BSM
+	help
+	  Re-enable the BSM on kernel startup
+
+config PENSANDO_SOC_PENFW
+	bool "Pensando penfw driver"
+	default n
+	help
+	  Driver module to interface secure boot config
+
+config PENSANDO_SOC_SBUS
+	tristate "Pensando sbus read/write driver"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC sbus read/write driver
+
+endmenu
+
+endif
diff --git a/drivers/soc/pensando/Makefile b/drivers/soc/pensando/Makefile
new file mode 100644
index 000000000000..69e60319b1ba
--- /dev/null
+++ b/drivers/soc/pensando/Makefile
@@ -0,0 +1,17 @@
+#
+# Pensando SoC drivers
+#
+obj-y += cap_soc.o
+
+CFLAGS_cap_mem.o := -I$(src)
+ccflags-$(CONFIG_PENSANDO_SOC_PCIE) += -DPEN_COMPAT_V2
+
+obj-$(CONFIG_PENSANDO_SOC_CAPMEM) += cap_mem.o
+obj-$(CONFIG_PENSANDO_SOC_PCIE) += cap_pcie.o cap_reboot.o
+obj-$(CONFIG_PENSANDO_SOC_PCIE) += kpcimgr.o kpcimgr_sysfs.o
+obj-$(CONFIG_PENSANDO_SOC_RSTCAUSE) += cap_rstcause.o
+obj-$(CONFIG_PENSANDO_SOC_CRASH) += cap_crash.o
+obj-$(CONFIG_PENSANDO_SOC_BSM) += cap_bsm.o
+obj-$(CONFIG_PENSANDO_SOC_PENFW) += penfw_smc.o penfw_sysfs.o penfw_drv.o
+obj-$(CONFIG_PENSANDO_SOC_SBUS) += sbus.o
+obj-$(CONFIG_ARCH_PENSANDO_SALINA_SOC) += cmn_pmu_irq.o
diff --git a/drivers/soc/pensando/bsm_dev.h b/drivers/soc/pensando/bsm_dev.h
new file mode 100644
index 000000000000..7e31269e30cd
--- /dev/null
+++ b/drivers/soc/pensando/bsm_dev.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019-2021, Pensando Systems Inc.
+ */
+
+#ifndef _BSM_DEV_H_
+#define _BSM_DEV_H_
+
+#define BSM_WDT_LSB		10
+#define BSM_WDT_MASK		0x1
+#define BSM_FWID_LSB		8
+#define BSM_FWID_MASK		0x3
+#define BSM_ATTEMPT_LSB		6
+#define BSM_ATTEMPT_MASK	0x3
+#define BSM_TRACK_LSB		4
+#define BSM_TRACK_MASK		0x3
+#define BSM_STAGE_LSB		2
+#define BSM_STAGE_MASK		0x3
+#define BSM_RUNNING_LSB		1
+#define BSM_RUNNING_MASK	0x1
+#define BSM_AUTOBOOT_LSB	0
+#define BSM_AUTOBOOT_MASK	0x1
+
+#endif
diff --git a/drivers/soc/pensando/cap_bsm.c b/drivers/soc/pensando/cap_bsm.c
new file mode 100644
index 000000000000..5a99cb7c4900
--- /dev/null
+++ b/drivers/soc/pensando/cap_bsm.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019-2021, Pensando Systems Inc.
+ */
+
+#include <linux/export.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include "bsm_dev.h"
+
+extern struct kobject *pensando_fw_kobj_get(void);
+
+struct bsm {
+	void __iomem *base;
+	uint32_t val;
+};
+static struct bsm bsm;
+
+#define BSM_SHOW_INT(n, s) \
+	static ssize_t n##_show(struct device *dev,			\
+			struct device_attribute *attr, char *buf)	\
+	{								\
+		int val = (bsm.val >> BSM_##s##_LSB) & BSM_##s##_MASK;	\
+		return sprintf(buf, "%d\n", val);			\
+	}								\
+	static DEVICE_ATTR_RO(n)
+
+BSM_SHOW_INT(wdt,      WDT);
+BSM_SHOW_INT(attempt,  ATTEMPT);
+BSM_SHOW_INT(stage,    STAGE);
+BSM_SHOW_INT(running,  RUNNING);
+BSM_SHOW_INT(autoboot, AUTOBOOT);
+
+static const char *fwnames[4] = {
+	"mainfwa", "mainfwb", "goldfw", "diagfw"
+};
+
+#define BSM_SHOW_FWID(n, s) \
+	static ssize_t n##_show(struct device *dev,			\
+			struct device_attribute *attr, char *buf)	\
+	{								\
+		int val = (bsm.val >> BSM_##s##_LSB) & BSM_##s##_MASK;	\
+		return sprintf(buf, "%s\n", fwnames[val & 0x3]);	\
+	}								\
+	static DEVICE_ATTR_RO(n)
+
+BSM_SHOW_FWID(fwid,  FWID);
+BSM_SHOW_FWID(track, TRACK);
+
+static ssize_t success_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	long val;
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+	if (val) {
+		bsm.val &= ~(1 << BSM_RUNNING_LSB);
+		writel(bsm.val, bsm.base);
+	}
+
+	return count;
+}
+static DEVICE_ATTR_WO(success);
+
+static const struct device_attribute *bsm_attrs[] = {
+	&dev_attr_wdt,
+	&dev_attr_fwid,
+	&dev_attr_attempt,
+	&dev_attr_track,
+	&dev_attr_stage,
+	&dev_attr_running,
+	&dev_attr_autoboot,
+	&dev_attr_success,
+};
+
+static int bsm_probe(struct platform_device *pdev)
+{
+	struct kobject *pensando_kobj;
+	int i, r = 0;
+
+	if (bsm.base == NULL) {
+		/* bsm not in device-tree */
+		return -ENODEV;
+	}
+	pensando_kobj = pensando_fw_kobj_get();
+	if (!pensando_kobj)
+		return -ENOMEM;
+	for (i = 0; i < ARRAY_SIZE(bsm_attrs); i++) {
+		r = device_create_file(&pdev->dev, bsm_attrs[i]);
+		if (r) {
+			pr_err("failed to create sysfs file\n");
+			return r;
+		}
+	}
+	r = sysfs_create_link(pensando_kobj, &pdev->dev.kobj, "bsm");
+	if (r) {
+		pr_err("failed to create sysfs symlink\n");
+		kobject_put(pensando_kobj);
+		return r;
+	}
+	return 0;
+}
+
+static const struct of_device_id bsm_of_match[] = {
+	{ .compatible = "pensando,bsm" },
+};
+
+static struct platform_driver bsm_driver = {
+	.driver = {
+		.name = "elba-bsm",
+		.of_match_table = bsm_of_match,
+		.suppress_bind_attrs = true,
+	},
+	.probe = bsm_probe,
+};
+builtin_platform_driver(bsm_driver);
+
+/*
+ * Boot State Machine init.
+ * If auto-booting, then set the BSM_RUNNING bit in the BSM register
+ * to continue BSM protection.	The bit will be cleared when userland comes up.
+ */
+static int __init cap_bsm_init(void)
+{
+	const struct of_device_id *match;
+	struct device_node *np;
+	struct resource res;
+
+	np = of_find_matching_node_and_match(NULL, bsm_of_match, &match);
+	if (!np) {
+		/* Not found in the device-tree.  Quietly resign */
+		return 0;
+	}
+	if (of_address_to_resource(np, 0, &res) < 0) {
+		pr_err("failed to get BSM registers\n");
+		of_node_put(np);
+		return -ENXIO;
+	}
+	of_node_put(np);
+
+	bsm.base = ioremap(res.start, resource_size(&res));
+	if (!bsm.base) {
+		pr_err("failed to map BSM register\n");
+		return -ENXIO;
+	}
+
+	bsm.val = readl(bsm.base);
+#ifdef CONFIG_PENSANDO_SOC_BSM_ENABLE
+	if (bsm.val & (1 << BSM_AUTOBOOT_LSB)) {
+		bsm.val |= 1 << BSM_RUNNING_LSB;
+		writel(bsm.val, bsm.base);
+	}
+#endif
+	return 0;
+}
+early_initcall(cap_bsm_init);
diff --git a/drivers/soc/pensando/cap_crash.c b/drivers/soc/pensando/cap_crash.c
new file mode 100644
index 000000000000..555c35e56c78
--- /dev/null
+++ b/drivers/soc/pensando/cap_crash.c
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019-2022, Pensando Systems Inc.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/kmsg_dump.h>
+#include <linux/time.h>
+#include <linux/panic_notifier.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include "cap_reboot.h"
+
+#define PCRASH_NAME	"pensando-crash"
+
+struct pcrash_st {
+	struct platform_device	*pdev;
+	struct kmsg_dumper	dump;
+	void __iomem		*flashbase;
+	resource_size_t		size;
+	void *panic_buf;
+};
+
+struct panicbuf_header {
+	u32 magic;
+	u32 len;
+};
+
+static struct pcrash_st *pcrash;
+static u32 PANIC_SIGNATURE = 0x9D7A7318;
+
+static void pcrash_do_dump(struct kmsg_dumper *dumper,
+			   enum kmsg_dump_reason reason)
+{
+	int idx;
+	u32 *src;
+	size_t kmsg_dump_len;
+	struct kmsg_dump_iter iter;
+	u32 __iomem *dst = (u32 *)pcrash->flashbase;
+	struct panicbuf_header *hdr = pcrash->flashbase;
+
+	/*
+	 * read first 32bits, if all ff then the new panic data
+	 * can be written to the panic buf.
+	 */
+	if (hdr->magic == 0xffffffff) {
+		kmsg_dump_rewind(&iter);
+		kmsg_dump_get_buffer(&iter, false, pcrash->panic_buf,
+				pcrash->size - sizeof(struct panicbuf_header), &kmsg_dump_len);
+
+		/* write the signature to panic buf log */
+		hdr->magic = PANIC_SIGNATURE;
+		hdr->len = kmsg_dump_len;
+		src = (u32 *)pcrash->panic_buf;
+		dst = (u32 *)(hdr + 1);
+		for (idx = 0; idx < roundup(kmsg_dump_len, 4) / 4; idx++)
+			*dst++ = *src++;
+	}
+}
+
+static int cap_panic_callback(struct notifier_block *nb,
+			       unsigned long reason, void *arg)
+{
+	struct timespec64 ts;
+	struct tm tm;
+
+	ktime_get_real_ts64(&ts);
+	time64_to_tm(ts.tv_sec, 0, &tm);
+	pr_info("Panic at Boot #%lu %04ld-%02d-%02d %02d:%02d:%02d.%06ld\n",
+		cap_boot_count(),
+		tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec,
+		ts.tv_nsec / 1000);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block cap_panic_notifier = {
+	.notifier_call = cap_panic_callback,
+};
+
+static int pcrash_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int err;
+
+	pcrash = devm_kzalloc(dev, sizeof(*pcrash), GFP_KERNEL);
+	if (!pcrash)
+		return -ENOMEM;
+
+	pcrash->pdev = pdev;
+	platform_set_drvdata(pdev, pcrash);
+
+	pcrash->dump.max_reason = KMSG_DUMP_PANIC;
+	pcrash->dump.dump = pcrash_do_dump;
+
+	/* Obtain and remap flash address. */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pcrash->flashbase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(pcrash->flashbase)) {
+		dev_err(dev, "Cannot remap flash address.\n");
+		return PTR_ERR(pcrash->flashbase);
+	}
+	pcrash->size = resource_size(res);
+	pcrash->panic_buf = vmalloc(pcrash->size);
+	if (!pcrash->panic_buf) {
+		dev_err(dev, "failed to allocate buffer workspace\n");
+		return -ENOMEM;
+	}
+	memset(pcrash->panic_buf, 0xff, pcrash->size);
+	atomic_notifier_chain_register(&panic_notifier_list,
+				       &cap_panic_notifier);
+	err = kmsg_dump_register(&pcrash->dump);
+	if (err) {
+		vfree(pcrash->panic_buf);
+		dev_err(dev, "%s: registering kmsg dumper failed, error %d\n", __func__, err);
+		return err;
+	}
+	return 0;
+}
+
+static int pcrash_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	if (kmsg_dump_unregister(&pcrash->dump) < 0)
+		dev_err(dev, "could not unregister kmsg_dumper\n");
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+					 &cap_panic_notifier);
+	vfree(pcrash->panic_buf);
+	return 0;
+}
+
+static const struct of_device_id pcrash_dt_ids[] = {
+	{.compatible = "pensando,capri-crash",},
+	{ /* end of table */ }
+};
+
+MODULE_DEVICE_TABLE(of, pcrash_dt_ids);
+
+static struct platform_driver pcrash_platform_driver = {
+	.probe = pcrash_probe,
+	.remove = pcrash_remove,
+	.driver = {
+		.name = PCRASH_NAME,
+		.of_match_table = pcrash_dt_ids,
+	},
+};
+
+module_platform_driver(pcrash_platform_driver);
+
+MODULE_DESCRIPTION("Pensando Panic Crash Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" PCRASH_NAME);
+MODULE_AUTHOR("Rahul Shekhar <rahulshekhar@pensando.io>");
diff --git a/drivers/soc/pensando/cap_mem.c b/drivers/soc/pensando/cap_mem.c
new file mode 100644
index 000000000000..75f61c0068d2
--- /dev/null
+++ b/drivers/soc/pensando/cap_mem.c
@@ -0,0 +1,519 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2022, Pensando Systems Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/sort.h>
+#include <linux/pfn_t.h>
+#include <dt-bindings/soc/pensando,capmem.h>
+#include "capmem_dev.h"
+
+#define CREATE_TRACE_POINTS
+#include "cap_tracepoint.h"
+
+#define CAPMEM_REGION_ALIGN		PMD_SIZE
+
+/* page entry size for vm->huge_fault() */
+enum page_entry_size {
+	PE_SIZE_PTE = 0,
+	PE_SIZE_PMD,
+	PE_SIZE_PUD,
+};
+
+/*
+ * Memory range information provided by U-Boot on the kernel commandline:
+ * Syntax:
+ *	start-end:type[,start-end:type]
+ *	    start:  hex start address (no 0x prefix)
+ *	    end:    hex end address (inclusive)
+ *	    type:   address space type: coherent | noncoherent
+ * Eg:
+ *	capmem=c0000000-c3f00000:coherent,c8000000-13fffffff:noncoherent
+ *
+ * Only address ranges specified are allowed to be mapped.
+ */
+static char *ranges;
+#ifdef MODULE
+module_param(ranges, charp, 0);
+#else
+static int __init capmem_setup(char *s)
+{
+	ranges = s;
+	return 0;
+}
+__setup("capmem=", capmem_setup);
+#endif
+
+static struct capmem_range mem_range[CAPMEM_MAX_RANGES];
+static int nmem_ranges;
+
+static int capmem_add_range(uint64_t start, uint64_t len, int type)
+{
+	struct capmem_range *p = &mem_range[nmem_ranges];
+
+	if (nmem_ranges == CAPMEM_MAX_RANGES)
+		return -ENOMEM;
+	p->start = start;
+	p->len = len;
+	p->type = type;
+	++nmem_ranges;
+	return 0;
+}
+
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+static vm_fault_t cap_mem_pte_fault(struct vm_fault *vmf)
+{
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	vm_fault_t rc;
+
+	trace_cap_mem_pte_fault(vma, vmf);
+
+	pgoff = vmf->pgoff;
+	phys = PFN_PHYS(pgoff);
+
+	trace_cap_mem_vmf_insert_pfn_pte(vma, vmf, phys);
+
+	rc = vmf_insert_pfn(vma, vmf->address, PFN_DOWN(phys));
+	if (rc == -ENOMEM)
+		return VM_FAULT_OOM;
+	if (rc < 0 && rc != -EBUSY)
+		return VM_FAULT_SIGBUS;
+
+	return VM_FAULT_NOPAGE;
+}
+
+static vm_fault_t cap_mem_pmd_fault(struct vm_fault *vmf)
+{
+	unsigned long pmd_addr = vmf->address & PMD_MASK;
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	pfn_t pfn;
+
+	trace_cap_mem_pmd_fault(vma, vmf);
+
+	if (pmd_addr < vma->vm_start || (pmd_addr + PMD_SIZE) > vma->vm_end)
+		return VM_FAULT_FALLBACK;
+
+	pgoff = linear_page_index(vma, pmd_addr);
+	phys = PFN_PHYS(pgoff);
+
+	if (!IS_ALIGNED(phys, PMD_SIZE))
+		return VM_FAULT_FALLBACK;
+
+	trace_cap_mem_vmf_insert_pfn_pmd(vma, vmf, phys);
+
+	pfn = phys_to_pfn_t(phys, PFN_DEV|PFN_MAP);
+
+	return vmf_insert_pfn_pmd(vmf, pfn, vmf->flags & FAULT_FLAG_WRITE);
+}
+
+#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
+static vm_fault_t cap_mem_pud_fault(struct vm_fault *vmf)
+{
+	unsigned long pud_addr = vmf->address & PUD_MASK;
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	pfn_t pfn;
+
+	trace_cap_mem_pud_fault(vma, vmf);
+
+	if (pud_addr < vma->vm_start || (pud_addr + PUD_SIZE) > vma->vm_end)
+		return VM_FAULT_FALLBACK;
+
+	pgoff = linear_page_index(vma, pud_addr);
+	phys = PFN_PHYS(pgoff);
+
+	if (!IS_ALIGNED(phys, PUD_SIZE))
+		return VM_FAULT_FALLBACK;
+
+	trace_cap_mem_vmf_insert_pfn_pud(vma, vmf, phys);
+
+	pfn = phys_to_pfn_t(phys, PFN_DEV|PFN_MAP);
+
+	return vmf_insert_pfn_pud(vmf, pfn, vmf->flags & FAULT_FLAG_WRITE);
+}
+#else
+static vm_fault_t cap_mem_pud_fault(struct vm_fault *vmf)
+{
+	return VM_FAULT_FALLBACK;
+}
+#endif /* !CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD */
+
+static vm_fault_t cap_mem_huge_fault(struct vm_fault *vmf,
+		enum page_entry_size pe_size)
+{
+	vm_fault_t rc;
+
+	trace_cap_mem_fault_enter(vmf->vma, vmf);
+
+	switch (pe_size) {
+	case PE_SIZE_PTE:
+		rc = cap_mem_pte_fault(vmf);
+		break;
+	case PE_SIZE_PMD:
+		rc = cap_mem_pmd_fault(vmf);
+		break;
+	case PE_SIZE_PUD:
+		rc = cap_mem_pud_fault(vmf);
+		break;
+	default:
+		rc = VM_FAULT_SIGBUS;
+	}
+
+	trace_cap_mem_fault_exit(vmf->vma, vmf);
+
+	return rc;
+}
+
+static vm_fault_t cap_mem_fault(struct vm_fault *vmf)
+{
+	return cap_mem_huge_fault(vmf, PE_SIZE_PTE);
+}
+
+static int cap_mem_may_split(struct vm_area_struct *vma, unsigned long addr)
+{
+	return -EINVAL;
+}
+
+static const struct vm_operations_struct cap_mem_vm_ops = {
+	.fault = cap_mem_fault,
+	.huge_fault = cap_mem_huge_fault,
+	.may_split = cap_mem_may_split,
+};
+
+static unsigned long cap_mem_get_unmapped_area(struct file *filp,
+		unsigned long addr, unsigned long len, unsigned long pgoff,
+		unsigned long flags)
+{
+	unsigned long off, len_align, addr_align, align;
+
+	align = PAGE_SIZE;
+	off = pgoff << PAGE_SHIFT;
+
+	if (len >= PMD_SIZE && IS_ALIGNED(off, PMD_SIZE))
+		align = PMD_SIZE;
+
+#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
+	if (len >= PUD_SIZE && IS_ALIGNED(off, PUD_SIZE))
+		align = PUD_SIZE;
+#endif
+
+	trace_cap_mem_get_unmapped_area_enter(addr, len, pgoff, align);
+
+	if (align == PAGE_SIZE)
+		goto out;
+
+	len_align = len + align;
+
+	addr = current->mm->get_unmapped_area(filp, addr, len_align, pgoff, flags);
+	if (!IS_ERR_VALUE(addr)) {
+		addr_align = round_up(addr, align);
+		trace_cap_mem_get_unmapped_area_exit(addr_align, len_align, pgoff, align);
+		return addr_align;
+	}
+
+out:
+	addr = current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);
+	trace_cap_mem_get_unmapped_area_exit(addr, len, pgoff, align);
+	return addr;
+}
+#endif
+
+static int cap_mem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	size_t size = vma->vm_end - vma->vm_start;
+	phys_addr_t p_start = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;
+	phys_addr_t p_end = p_start + size - 1;
+	pgprot_t pgprot = vma->vm_page_prot;
+	int i;
+
+	// range cannot wrap
+	if (p_end <= p_start)
+		return -EINVAL;
+
+	// must be MAP_SHARED
+	if (!(vma->vm_flags & VM_MAYSHARE))
+		return -EINVAL;
+
+	// find permitted range
+	for (i = 0; i < nmem_ranges; i++)
+		if (p_start >= mem_range[i].start &&
+		    p_end < (mem_range[i].start + mem_range[i].len))
+			break;
+	if (i == nmem_ranges)
+		return -EPERM;
+
+	switch (mem_range[i].type) {
+	case CAPMEM_TYPE_DEVICE:
+		/* register space must be device-mapped */
+		pgprot = pgprot_device(pgprot);
+		vm_flags_set(vma, VM_IO);
+		break;
+
+	case CAPMEM_TYPE_NONCOHERENT:
+	case CAPMEM_TYPE_BYPASS:
+		/*
+		 * An inner shareable cached mapping on a noncoherence range
+		 * is invalid, so only accept non-cached mapping requests.
+		 */
+		if (!(file->f_flags & O_SYNC))
+			return -EINVAL;
+		pgprot = pgprot_writecombine(pgprot);
+		break;
+
+	default:
+		// CAPMEM_TYPE_COHERENT - default inner shareable mapping
+		break;
+	}
+
+	/*
+	 * Clear the RDONLY bit and set the DIRTY bit to bypass the
+	 * kernel's clean/dirty page tracking, which uses a page fault on
+	 * first write behavior, which is undesirable for performance.
+	 */
+	if (vma->vm_flags & VM_WRITE)
+		pgprot = __pgprot_modify(pgprot, PTE_RDONLY, PTE_DIRTY);
+
+	vma->vm_page_prot = pgprot;
+
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+	vma->vm_ops = &cap_mem_vm_ops;
+	vm_flags_set(vma, VM_PFNMAP | VM_HUGEPAGE | VM_DONTEXPAND | VM_DONTDUMP);
+#else
+	/* Remap-pfn-range will mark the range VM_IO */
+	if (remap_pfn_range(vma,
+			    vma->vm_start,
+			    vma->vm_pgoff,
+			    size,
+			    vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+#endif
+
+	return 0;
+}
+
+/*
+ * Map a capmem range type to a legacy type for v1 commands
+ */
+static int compat_range_type(unsigned int cmd, int type)
+{
+	if (cmd == CAPMEM_GET_RANGES && type == CAPMEM_TYPE_BYPASS)
+		return CAPMEM_TYPE_NONCOHERENT;
+	else
+		return type;
+}
+
+static long cap_mem_unlocked_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	void __user *p = (void __user *)arg;
+	struct capmem_range __user *rp;
+	struct capmem_ranges_args gr;
+	struct capmem_range range;
+	int i;
+
+	switch (cmd) {
+	case CAPMEM_GET_NRANGES:
+		return put_user(nmem_ranges, (int __user *)p);
+
+	case CAPMEM_GET_RANGES:
+	case CAPMEM_GET_RANGES2:
+		if (copy_from_user(&gr, p, sizeof(gr)))
+			return -EFAULT;
+		rp = (struct capmem_range __user *)gr.range;
+		for (i = 0; i < gr.nranges; i++) {
+			if (i >= nmem_ranges)
+				return i;
+			range = mem_range[i];
+			range.type = compat_range_type(cmd, range.type);
+			if (copy_to_user(rp, &range, sizeof(*rp)))
+				return -EFAULT;
+			++rp;
+		}
+		return i;
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+const struct file_operations cap_mem_fops = {
+	.owner		= THIS_MODULE,
+	.mmap		= cap_mem_mmap,
+	.unlocked_ioctl	= cap_mem_unlocked_ioctl,
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+	.get_unmapped_area = cap_mem_get_unmapped_area,
+#endif
+};
+
+static struct miscdevice cap_mem_dev = {
+	MISC_DYNAMIC_MINOR,
+	CAPMEM_NAME,
+	&cap_mem_fops
+};
+
+static int __init parse_memory_ranges(struct platform_device *pdev, char *s)
+{
+	uint64_t start, end, len;
+	char *p, *q;
+	int r, type;
+
+	if (!s)
+		return 0;
+
+	while ((p = strsep(&s, ",")) != NULL) {
+		if (nmem_ranges == CAPMEM_MAX_RANGES) {
+			dev_err(&pdev->dev, "too many ranges\n");
+			return -ENODEV;
+		}
+		q = strchr(p, ':');
+		if (!q)
+			goto syntax;
+		*q++ = '\0';
+		if (sscanf(p, "%llx-%llx", &start, &end) != 2)
+			goto syntax;
+		if (end <= start)
+			goto syntax;
+		if (strcmp(q, "coherent") == 0)
+			type = CAPMEM_TYPE_COHERENT;
+		else if (strcmp(q, "noncoherent") == 0)
+			type = CAPMEM_TYPE_NONCOHERENT;
+		else
+			goto syntax;
+		len = end - start + 1;
+		r = capmem_add_range(start, len, type);
+		if (r)
+			return r;
+	}
+	return 0;
+syntax:
+	dev_err(&pdev->dev, "invalid range syntax\n");
+	return -EINVAL;
+}
+
+/*
+ * Load ranges from the device-tree
+ * Each range row comprises 5 words:
+ *	<start_hi start_lo size_hi size_lo attr>
+ *	attr is { unused:29, device:1, bypass:1, coherent:1 }
+ */
+static int load_of_ranges(struct platform_device *pdev, const char *pname)
+{
+	u32 entries[CAPMEM_MAX_RANGES][5];
+	int r, n, i, type;
+	u64 start, len;
+	u32 attr;
+
+	n = of_property_read_variable_u32_array(pdev->dev.of_node,
+			pname, (u32 *)entries, 0,
+			sizeof(entries) / sizeof(u32));
+	if (n < 0)
+		return -ENOENT;
+
+	if (n % 5 != 0) {
+		dev_err(&pdev->dev, "of %s invalid\n", pname);
+		return -ENODEV;
+	}
+	n /= 5;
+	for (i = 0; i < n; i++) {
+		attr = entries[i][4];
+		if (attr & DSC_MEM_ATTR_DEVICE)
+			type = CAPMEM_TYPE_DEVICE;
+		else if (attr & DSC_MEM_ATTR_BYPASS)
+			type = CAPMEM_TYPE_BYPASS;
+		else if (attr & DSC_MEM_ATTR_COHERENT)
+			type = CAPMEM_TYPE_COHERENT;
+		else
+			type = CAPMEM_TYPE_NONCOHERENT;
+		start = ((u64)entries[i][0] << 32) | entries[i][1];
+		len   = ((u64)entries[i][2] << 32) | entries[i][3];
+		r = capmem_add_range(start, len, type);
+		if (r)
+			return r;
+	}
+	return 0;
+}
+
+static int cmp_ranges(const void *a, const void *b)
+{
+	const struct capmem_range *r1 = a;
+	const struct capmem_range *r2 = b;
+
+	if (r1->start == r2->start)
+		return 0;
+	else
+		return (r1->start < r2->start) ? -1 : 1;
+}
+
+static int capmem_probe(struct platform_device *pdev)
+{
+	int r;
+
+	dev_info(&pdev->dev, "Loading capmem driver\n");
+
+	/* load the fixed ranges from the device-tree */
+	r = load_of_ranges(pdev, "pensando,capmem-fixed-ranges");
+	if (r == -ENOENT)
+		return r;
+
+	/*
+	 * load the ranges installed by u-boot; either in the device-tree
+	 * or provided as a module parameter.
+	 */
+	r = load_of_ranges(pdev, "pensando,capmem-ranges");
+	if (r == -ENOENT) {
+		/* fallback to the capmem= variable */
+		r = parse_memory_ranges(pdev, ranges);
+		if (r)
+			return r;
+	}
+
+	/*
+	 * Sort ranges by ascending physical address.
+	 */
+	sort(mem_range, nmem_ranges, sizeof(mem_range[0]), cmp_ranges, NULL);
+
+	return misc_register(&cap_mem_dev);
+}
+
+static int capmem_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "Unloading capmem driver\n");
+	misc_deregister(&cap_mem_dev);
+	return 0;
+}
+
+static const struct of_device_id capmem_of_match[] = {
+	{ .compatible = "pensando,capmem" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver capmem_driver = {
+	.probe = capmem_probe,
+	.remove = capmem_remove,
+	.driver = {
+		.name = "capmem",
+		.owner = THIS_MODULE,
+		.of_match_table = capmem_of_match,
+	},
+};
+
+module_platform_driver(capmem_driver);
+MODULE_DESCRIPTION("Pensando SoC Memory Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/pensando/cap_pcie.c b/drivers/soc/pensando/cap_pcie.c
new file mode 100644
index 000000000000..1bfc15bb7bc8
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie.c
@@ -0,0 +1,456 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019-2022, Pensando Systems Inc.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/ioctl.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <asm/traps.h>
+#include "cap_reboot.h"
+#include "cap_rstcause.h"
+#include "penpcie_dev.h"
+#ifdef CONFIG_ARCH_PENSANDO_CAPRI_SOC
+#include "cap_pcie_capri.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_ELBA_SOC
+#include "cap_pcie_elba.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_GIGLIO_SOC
+#include "cap_pcie_giglio.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_SALINA_SOC
+#include "cap_pcie_salina.h"
+#endif
+
+#define DRV_NAME	"cap_pcie"
+#define PFX		DRV_NAME ": "
+
+/* device resource indexes */
+#define MS_CFG_WDT_IDX  0
+#define WDT_IDX         1
+#define PCIE_IDX	2
+
+struct pciedev_info {
+	u32 __iomem *ms_cfg_wdt;
+	u32 __iomem *wdt;
+	void __iomem *pcieva;
+	u64 pcie_base;
+	u64 pcie_size;
+	u64 pciep_access_address;
+	int pciep_access_error;
+	spinlock_t pciep_access_lock;
+	long (*saved_panic_blink)(int state);
+	u32 hotplug_delaylnkup;
+};
+
+static struct pciedev_info pciedev_info;
+
+static void *pcie_ptov(const u64 pciepa)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	const u64 pcieoff = pciepa - pi->pcie_base;
+
+	return pi->pcieva + pcieoff;
+}
+
+static u32 pcie_readl(const u64 pciepa)
+{
+	return readl(pcie_ptov(pciepa));
+}
+
+static void pcie_writel(const u32 val, const u64 pciepa)
+{
+	writel(val, pcie_ptov(pciepa));
+}
+
+static int pciep_access_in_progress(void)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (pi->pciep_access_address) {
+		pi->pciep_access_error++;
+		return 1;
+	}
+	return 0;
+}
+
+int platform_serror(struct pt_regs *regs, unsigned int esr)
+{
+	if (pciep_access_in_progress())
+		return 1;
+
+	// TODO: Salina N1 async SError user mode convert to bus error
+	// ESR_ELx[5:0] = 0b010001  Asynchronous SError exception
+	if (((esr & 0x11) == 0x11) ||
+	    ((esr >> 26) == 0x2f && (esr & 0x3) == 0x0)) { /* Decode Error */
+		if (user_mode(regs)) {
+			struct task_struct *tsk = current;
+
+			pr_info("%s[%d]: serror converted to bus error\n",
+				tsk->comm, task_pid_nr(tsk));
+			force_signal_inject(SIGBUS, BUS_ADRERR, regs->pc, esr);
+		} else {
+			/* ignore */
+			pr_info("ignoring serror decode-error in kernel mode\n");
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
+static void pciep_access_begin(const u64 pciepa)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	pi->pciep_access_address = pciepa;
+	pi->pciep_access_error = 0;
+}
+
+static int pciep_access_end(void)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (pi->pciep_access_error) {
+		pr_info_ratelimited("pcie access serror: address 0x%llx\n",
+				    pi->pciep_access_address);
+	}
+	pi->pciep_access_address = 0;
+	return pi->pciep_access_error;
+}
+
+static int pciep_valid_pa(const uint64_t pciepa, const uint32_t size)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (!pi->pcieva)
+		return -ENXIO;
+	if (pciepa < pi->pcie_base ||
+	    pciepa > pi->pcie_base + pi->pcie_size ||
+	    size > pi->pcie_size ||
+	    pciepa + size > pi->pcie_base + pi->pcie_size)
+		return -ERANGE;
+	return 0;
+}
+
+/*
+ * Protect reads to pcie registers in the pcie clock domain.
+ * The pcie refclock can be removed by the system without warning,
+ * and outstanding read requests to these registers will generate
+ * an AXI read error response.  ARM will treat this as an asynchronous
+ * System Error (SError) event.  The default handling of SError is to
+ * send SIGILL if SError arrives while in user space, or panic if the
+ * SError arrives when not in process context.  Neither of these responses
+ * is desireable for our case where a pcie register might be accessed
+ * just as the pcie refclock gets removed.  Here we detect the SError
+ * event during our pcie register access and return failure to the
+ * caller, but the system continues.
+ */
+int pciep_regrd32(const uint64_t pciepa, uint32_t *val)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	int r;
+	unsigned long flags;
+
+	r = pciep_valid_pa(pciepa, sizeof(u32));
+	if (r)
+		return r;
+
+	spin_lock_irqsave(&pi->pciep_access_lock, flags);
+	pciep_access_begin(pciepa);
+
+	*val = pcie_readl(pciepa);
+	asm volatile("msr daifclr, #4" ::: "memory"); /* unmask async SError */
+	dsb(sy);		/* sync in-flight ld/st */
+	isb();
+
+	r = pciep_access_end();
+	spin_unlock_irqrestore(&pi->pciep_access_lock, flags);
+	if (r)
+		return -EIO;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pciep_regrd32);
+
+static long pcie_unlocked_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	void __user *p = (void __user *)arg;
+	struct pcie_rw rw;
+	uint32_t val;
+	int r;
+
+	switch (cmd) {
+
+	case PCIE_PCIEP_REGRD:
+		if (copy_from_user(&rw, p, sizeof(rw)))
+			return -EFAULT;
+		if (rw.size != sizeof(u32))
+			return -EINVAL;
+		r = pciep_regrd32(rw.pciepa, &val);
+		if (r)
+			return r;
+		return copy_to_user(rw.rdvalp, &val, sizeof(val));
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+const struct file_operations pcie_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= pcie_unlocked_ioctl,
+};
+
+static struct miscdevice pcie_dev = {
+	MISC_DYNAMIC_MINOR,
+	PENPCIE_NAME,
+	&pcie_fops
+};
+
+static int pcieport_get_ltssm_en(const int port)
+{
+	const u32 val = pcie_readl(PXC_(CFG_C_PORT_MAC, port));
+
+	return (val & CFG_MACF_(0_2_LTSSM_EN)) != 0;
+}
+
+static int pcie_get_ltssm_en(void)
+{
+	int port;
+
+	for (port = 0; port < PCIEPORT_NPORTS; port++)
+		if (pcieport_get_ltssm_en(port))
+			return port;
+	return -1;
+}
+
+static void pcieport_set_crs(const int port, const int on)
+{
+	u32 val;
+
+	val = pcie_readl(PXC_(CFG_C_PORT_MAC, port));
+	if (on)
+		val |= CFG_MACF_(0_2_CFG_RETRY_EN);
+	else
+		val &= ~CFG_MACF_(0_2_CFG_RETRY_EN);
+	pcie_writel(val, PXC_(CFG_C_PORT_MAC, port));
+}
+
+static void pcie_set_crs(const int on)
+{
+	int port;
+
+	for (port = 0; port < PCIEPORT_NPORTS; port++)
+		pcieport_set_crs(port, on);
+}
+
+static int pcieport_poll_for_hostdn(const int port)
+{
+	const u32 val = pcie_readl(PXC_(INT_C_MAC_INTREG, port));
+
+	return (val & MAC_INTREGF_(RST_DN2UP)) != 0;
+}
+
+/*
+ * Detect if the host is rebooting by watching the pcie mac
+ * for an interrupt indicating the link went into reset.
+ */
+static int pcie_poll_for_hostdn(void)
+{
+	int port;
+
+	for (port = 0; port < PCIEPORT_NPORTS; port++)
+		if (pcieport_poll_for_hostdn(port))
+			return port;
+	return -1;
+}
+
+/*
+ * Asic reset using the WDT0 configured to reset immediately.
+ * Note that we do NOT touch the WDT config here until *after*
+ * we are in the panic handling.  The WDT might be used by the
+ * watchdog driver while the system is up, but here after a panic
+ * we take ownership of the WDT to reset the system.
+ *
+ * Note also this function never returns.
+ */
+static void cap_reset(void)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	u32 val;
+
+	pr_info(PFX "pensando reset!\n");
+
+	/* Enable WDT0 to reset the system */
+	val = ioread32(pi->ms_cfg_wdt);
+	val |= (1 << CFG_WDT_RST_EN);
+	iowrite32(val, pi->ms_cfg_wdt);
+
+	/* Configure WDT to immediately reset */
+	iowrite32(0, pi->wdt + WDT_TORR);
+	iowrite32(WDT_KICK_VAL, pi->wdt + WDT_CRR);
+	iowrite32(WDT_CR_PCLK_256, pi->wdt + WDT_CR);
+	iowrite32(WDT_CR_PCLK_256 | WDT_CR_ENABLE, pi->wdt + WDT_CR);
+	for (;;)
+		asm volatile("wfi");
+	/* NOTREACHED */
+}
+
+/*
+ * This function is called by the spin loop at the end of a
+ * system panic.  We'll watch for the host to reset and
+ * reset ourselves at the same time.
+ *
+ * If we haven't yet initialized the link (ltssm_en=0) then the
+ * host side hasn't come up yet.  In that case just reset immediately.
+ *
+ * If hotplug enabled then reset immediately
+ */
+static long pcie_panic_blink(int state)
+{
+	int port;
+
+	/* Check sysfs for immediate reboot */
+	if (cap_panic_reboot())
+		cap_reset();
+
+	port = pcie_get_ltssm_en();
+	if (!pciedev_info.hotplug_delaylnkup && port >= 0) {
+		pr_info(PFX "port %d enabled\n", port);
+		pcie_set_crs(0);
+		while ((port = pcie_poll_for_hostdn()) < 0)
+			continue;
+		pr_info(PFX "port %d hostdn\n", port);
+#ifdef CONFIG_PENSANDO_SOC_RSTCAUSE
+		/* reflect the pcie reset state in the reset cause */
+		cap_rstcause_set(CAP_RSTCAUSE_EV_PCIE_RESET);
+#endif
+	}
+	cap_reset();
+
+	/* NOTREACHED */
+	return 0;
+}
+
+static int map_resources(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	struct device_node *dn = pd->dev.of_node;
+
+	pi->ms_cfg_wdt = of_iomap(dn, MS_CFG_WDT_IDX);
+	pi->wdt = of_iomap(dn, WDT_IDX);
+	pi->pcieva = of_iomap(dn, PCIE_IDX);
+
+	if (IS_ERR(pi->ms_cfg_wdt) ||
+		IS_ERR(pi->wdt) ||
+		IS_ERR(pi->pcieva)) {
+		pr_err(PFX "iomap resources failed\n");
+		goto errout;
+	}
+	return 0;
+
+ errout:
+	if (pi->ms_cfg_wdt != NULL)
+		iounmap(pi->ms_cfg_wdt);
+	if (pi->wdt != NULL)
+		iounmap(pi->wdt);
+	if (pi->pcieva != NULL)
+		iounmap(pi->pcieva);
+	return -ENOMEM;
+}
+
+static void unmap_resources(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (pi->ms_cfg_wdt != NULL)
+		iounmap(pi->ms_cfg_wdt);
+	if (pi->wdt != NULL)
+		iounmap(pi->wdt);
+	if (pi->pcieva != NULL)
+		iounmap(pi->pcieva);
+}
+
+static int pcie_probe(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	struct device_node *dn = pd->dev.of_node;
+	struct resource res;
+	int err;
+
+	spin_lock_init(&pi->pciep_access_lock);
+
+	err = map_resources(pd);
+	if (err)
+		goto errout;
+
+	err = of_address_to_resource(dn, PCIE_IDX, &res);
+	if (err) {
+		pr_err(PFX "can't find PCIE_IDX res: %d\n", err);
+		goto errout_unmap;
+	}
+	pi->pcie_base = res.start;
+	pi->pcie_size = resource_size(&res);
+
+	of_property_read_u32(dn, "hotplug_delaylnkup", &pi->hotplug_delaylnkup);
+
+	err = misc_register(&pcie_dev);
+	if (err) {
+		pr_err(PFX "register pcie_dev failed: %d\n", err);
+		goto errout_unmap;
+	}
+
+	/*
+	 * Hook the panic_blink handler so we run after
+	 * all the panic notifiers and after all the
+	 * console msgs have been flushed.
+	 */
+	pi->saved_panic_blink = panic_blink;
+	panic_blink = pcie_panic_blink;
+	return 0;
+
+ errout_unmap:
+	unmap_resources(pd);
+ errout:
+	return err;
+}
+
+static int pcie_remove(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	misc_deregister(&pcie_dev);
+	panic_blink = pi->saved_panic_blink;
+	unmap_resources(pd);
+	return 0;
+}
+
+static const struct of_device_id pcie_of_match[] = {
+	{ .compatible = "pensando,pcie" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver pcie_driver = {
+	.probe = pcie_probe,
+	.remove = pcie_remove,
+	.driver = {
+		.name = "pensando-pcie",
+		.owner = THIS_MODULE,
+		.of_match_table = pcie_of_match,
+	},
+};
+module_platform_driver(pcie_driver);
diff --git a/drivers/soc/pensando/cap_pcie_capri.h b/drivers/soc/pensando/cap_pcie_capri.h
new file mode 100644
index 000000000000..ffd39d083e5c
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_capri.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_CAPRI_H__
+#define __CAP_PCIE_CAPRI_H__
+
+#define PCIEPORT_NPORTS		8
+
+#define CAP_ADDR_BASE_PP_PP_OFFSET 0x7000000
+#define CAP_PXC_CSR_BYTE_SIZE 0x00002000
+
+#define CAP_PP_CSR_PORT_C_CFG_C_PORT_MAC_BYTE_ADDRESS 0x110f8
+#define CAP_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
+#define CAP_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
+
+#define CAP_PP_CSR_PORT_C_INT_C_MAC_INTREG_BYTE_ADDRESS 0x111b0
+#define CAP_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
+
+#define _PP_BASE(pn)    CAP_ADDR_BASE_PP_PP_OFFSET
+#define PP_(REG, pn)	(_PP_BASE(pn) + CAP_PP_CSR_ ##REG## _BYTE_ADDRESS)
+#define _PXC_OFFSET(pn)	((pn) * CAP_PXC_CSR_BYTE_SIZE)
+#define _PXC_REG_(REG)	(CAP_PP_CSR_PORT_C_ ##REG## _BYTE_ADDRESS)
+#define PXC_(REG, pn)	(_PP_BASE(pn) + _PXC_OFFSET(pn) + _PXC_REG_(REG))
+
+#define CFG_MACF_(REG) \
+	(CAP_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
+#define MAC_INTREGF_(REG) \
+	(CAP_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
+
+#define CAP_MS_CSR_CFG_WDT_RST_EN_LSB 0
+#define CFG_WDT_RST_EN  CAP_MS_CSR_CFG_WDT_RST_EN_LSB
+
+#define WDT_CR          0x00
+#define WDT_TORR        0x01
+#define WDT_CRR         0x03
+
+#define WDT_CR_ENABLE   0x1
+#define WDT_CR_PCLK_256 (0x7 << 2)
+
+#define WDT_KICK_VAL    0x76
+
+#endif /* __CAP_PCIE_CAPRI_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_common.h b/drivers/soc/pensando/cap_pcie_common.h
new file mode 100644
index 000000000000..e54a0fdcf97e
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_common.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_COMMON_H__
+#define __CAP_PCIE_COMMON_H__
+
+#define ELB_ADDR_BASE_PP_PXC_0_OFFSET 0x20100000
+#define ELB_ADDR_BASE_PP_PXC_0_SIZE 0x40000
+#define ELB_ADDR_BASE_PP_PP_0_OFFSET 0x20300000
+#define ELB_ADDR_BASE_PP_PP_0_SIZE 0x40000
+
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_BYTE_ADDRESS 0x20f8
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
+
+#define ELB_PXC_CSR_INT_C_MAC_INTREG_BYTE_ADDRESS 0x2220
+#define ELB_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
+
+#define _PP_BASE(pn) \
+	(ELB_ADDR_BASE_PP_PP_0_OFFSET + \
+	(((pn) >> 2) * ELB_ADDR_BASE_PP_PP_0_SIZE))
+
+#define PP_(REG, pn) \
+	(_PP_BASE(pn) + ELB_PP_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define _PXC_BASE(pn) \
+	(ELB_ADDR_BASE_PP_PXC_0_OFFSET + \
+	((pn) * ELB_ADDR_BASE_PP_PXC_0_SIZE))
+
+#define PXC_(REG, pn) \
+	(_PXC_BASE(pn) + ELB_PXC_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define CFG_MACF_(REG) \
+	(ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
+#define MAC_INTREGF_(REG) \
+	(ELB_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
+
+#define ELB_SOC_CSR_CFG_WDT_RST_EN_LSB 0
+#define CFG_WDT_RST_EN  ELB_SOC_CSR_CFG_WDT_RST_EN_LSB
+
+#define WDT_CR          0x00
+#define WDT_TORR        0x01
+#define WDT_CRR         0x03
+
+#define WDT_CR_ENABLE   0x1
+#define WDT_CR_PCLK_256 (0x7 << 2)
+
+#define WDT_KICK_VAL    0x76
+
+#endif /* __CAP_PCIE_COMMON_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_elba.h b/drivers/soc/pensando/cap_pcie_elba.h
new file mode 100644
index 000000000000..e23ca250df93
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_elba.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021-2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_ELBA_H__
+#define __CAP_PCIE_ELBA_H__
+
+#include "cap_pcie_common.h"
+
+#define PCIEPORT_NPORTS		8
+
+#endif /* __CAP_PCIE_ELBA_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_giglio.h b/drivers/soc/pensando/cap_pcie_giglio.h
new file mode 100644
index 000000000000..ffe21a635ffc
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_giglio.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_GIGLIO_H__
+#define __CAP_PCIE_GIGLIO_H__
+
+#include "cap_pcie_common.h"
+
+#define PCIEPORT_NPORTS		4
+
+#endif /* __CAP_PCIE_GIGLIO_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_salina.h b/drivers/soc/pensando/cap_pcie_salina.h
new file mode 100644
index 000000000000..d1ff28bc9b5e
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_salina.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_SALA_H__
+#define __CAP_PCIE_SALA_H__
+
+#define PCIEPORT_NPORTS		8
+
+#define SAL_ADDR_BASE_PP_PXC_0_OFFSET 0x20100000
+#define SAL_ADDR_BASE_PP_PXC_0_SIZE 0x40000
+#define SAL_ADDR_BASE_PP_PP_0_OFFSET 0x20300000
+#define SAL_ADDR_BASE_PP_PP_0_SIZE 0x40000
+
+//Verify this offsets in Salina
+#define SAL_PXC_CSR_CFG_C_PORT_MAC_BYTE_ADDRESS 0x20f8
+#define SAL_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
+#define SAL_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
+
+#define SAL_PXC_CSR_INT_C_MAC_INTREG_BYTE_ADDRESS 0x2220
+#define SAL_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
+
+#define _PP_BASE(pn) \
+	(SAL_ADDR_BASE_PP_PP_0_OFFSET + \
+	(((pn) >> 2) * SAL_ADDR_BASE_PP_PP_0_SIZE))
+
+#define PP_(REG, pn) \
+	(_PP_BASE(pn) + SAL_PP_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define _PXC_BASE(pn) \
+	(SAL_ADDR_BASE_PP_PXC_0_OFFSET + \
+	((pn) * SAL_ADDR_BASE_PP_PXC_0_SIZE))
+
+#define PXC_(REG, pn) \
+	(_PXC_BASE(pn) + SAL_PXC_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define CFG_MACF_(REG) \
+	(SAL_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
+#define MAC_INTREGF_(REG) \
+	(SAL_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
+
+#define SAL_SOC_CSR_CFG_WDT_RST_EN_LSB 0
+#define CFG_WDT_RST_EN  SAL_SOC_CSR_CFG_WDT_RST_EN_LSB
+
+#define WDT_CR          0x00
+#define WDT_TORR        0x01
+#define WDT_CRR         0x03
+
+#define WDT_CR_ENABLE   0x1
+#define WDT_CR_PCLK_256 (0x7 << 2)
+
+#define WDT_KICK_VAL    0x76
+
+#endif /* __CAP_PCIE_SALA_H__ */
diff --git a/drivers/soc/pensando/cap_reboot.c b/drivers/soc/pensando/cap_reboot.c
new file mode 100644
index 000000000000..ddf2794fe80b
--- /dev/null
+++ b/drivers/soc/pensando/cap_reboot.c
@@ -0,0 +1,110 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pensando reboot control via sysfs
+ *
+ * Copyright (c) 2020-2022, Pensando Systems Inc.
+ */
+
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include "cap_reboot.h"
+
+/*
+ * This module provides userspace control of reboot behavior
+ * after a panic.  Naples25 SWM and OCP cards will use this
+ * to enable immediate reboot after panic handling.
+ */
+static int panic_reboot;	/* default=0, no reboot */
+
+/* value of system "boot_count" for panic logging */
+static unsigned long boot_count;
+
+bool cap_panic_reboot(void)
+{
+	if (panic_reboot)
+		return true;
+	return false;
+}
+
+unsigned long cap_boot_count(void)
+{
+	return boot_count;
+}
+
+struct kobject *reboot_kobj;
+
+static ssize_t panic_reboot_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", panic_reboot);
+}
+
+static ssize_t panic_reboot_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtoint(buf, 10, &panic_reboot);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t boot_count_show(struct kobject *kobj,
+			       struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", boot_count);
+}
+
+static ssize_t boot_count_store(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtoul(buf, 0, &boot_count);
+	if (ret)
+		return ret;
+	return count;
+}
+
+static struct kobj_attribute panic_reboot_attribute =
+	__ATTR(panic_reboot, 0644, panic_reboot_show, panic_reboot_store);
+static struct kobj_attribute boot_count_attribute =
+	__ATTR(boot_count, 0644, boot_count_show, boot_count_store);
+
+static struct attribute *attrs[] = {
+	&panic_reboot_attribute.attr,
+	&boot_count_attribute.attr,
+	NULL,
+};
+
+/* Put all attributes in the kobject directory */
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static int __init capri_reboot_init(void)
+{
+	int ret;
+
+	reboot_kobj = kobject_create_and_add("reboot_pensando", kernel_kobj);
+	if (!reboot_kobj)
+		return -ENOMEM;
+
+	ret = sysfs_create_group(reboot_kobj, &attr_group);
+	if (ret)
+		kobject_put(reboot_kobj);
+	return ret;
+}
+
+static void __exit capri_reboot_exit(void)
+{
+	kobject_put(reboot_kobj);
+}
+
+module_init(capri_reboot_init);
+module_exit(capri_reboot_exit);
diff --git a/drivers/soc/pensando/cap_reboot.h b/drivers/soc/pensando/cap_reboot.h
new file mode 100644
index 000000000000..e4bd89afe041
--- /dev/null
+++ b/drivers/soc/pensando/cap_reboot.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020-2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_REBOOT_H__
+#define __CAP_REBOOT_H__
+
+bool cap_panic_reboot(void);
+unsigned long cap_boot_count(void);
+
+#endif
diff --git a/drivers/soc/pensando/cap_rstcause.c b/drivers/soc/pensando/cap_rstcause.c
new file mode 100644
index 000000000000..3fdc7e456eaa
--- /dev/null
+++ b/drivers/soc/pensando/cap_rstcause.c
@@ -0,0 +1,217 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pensando restart cause driver
+ *
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sysfs.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/panic_notifier.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/init.h>
+#include <linux/reboot.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include "cap_rstcause.h"
+
+struct kobject *pensando_fw_kobj_get(void);
+
+struct cap_rstdev {
+	struct platform_device *pdev;
+	struct regmap *regs;
+	unsigned int regs_offset;
+	u32 this_cause;
+	struct notifier_block panic_nb;
+	struct notifier_block reboot_nb;
+	struct kobject *pensando_kobj;
+};
+
+static struct cap_rstdev *g_rdev;
+
+static inline u32 read_cause_reg(struct cap_rstdev *rdev)
+{
+	u32 val;
+
+	regmap_read(rdev->regs, rdev->regs_offset, &val);
+	return val;
+}
+
+static inline u32 read_next_cause_reg(struct cap_rstdev *rdev)
+{
+	u32 val;
+
+	regmap_read(rdev->regs, rdev->regs_offset + 4, &val);
+	return val;
+}
+
+static inline void set_next_cause_reg(struct cap_rstdev *rdev, u32 mask)
+{
+	regmap_update_bits(rdev->regs, rdev->regs_offset + 4, mask, ~0U);
+}
+
+void cap_rstcause_set(u32 mask)
+{
+	if (g_rdev)
+		set_next_cause_reg(g_rdev, mask);
+}
+EXPORT_SYMBOL_GPL(cap_rstcause_set);
+
+static int rstcause_reboot_handler(struct notifier_block *this,
+				   unsigned long code, void *unused)
+{
+	cap_rstcause_set(CAP_RSTCAUSE_EV_REBOOT);
+	return NOTIFY_OK;
+}
+
+static int rstcause_panic_handler(struct notifier_block *this,
+				  unsigned long code, void *unused)
+{
+	cap_rstcause_set(CAP_RSTCAUSE_EV_PANIC);
+	return NOTIFY_OK;
+}
+
+static ssize_t this_cause_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct cap_rstdev *rdev;
+
+	rdev = platform_get_drvdata(to_platform_device(dev));
+	return sprintf(buf, "0x%08x\n", rdev->this_cause);
+}
+
+static DEVICE_ATTR_RO(this_cause);
+
+static ssize_t next_cause_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct cap_rstdev *rdev;
+
+	rdev = platform_get_drvdata(to_platform_device(dev));
+	return sprintf(buf, "0x%08x\n", read_next_cause_reg(rdev));
+}
+
+static ssize_t next_cause_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct cap_rstdev *rdev;
+	unsigned long val;
+
+	rdev = platform_get_drvdata(to_platform_device(dev));
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+	if (val)
+		set_next_cause_reg(rdev, val);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(next_cause);
+
+static const struct device_attribute *rstcause_attrs[] = {
+	&dev_attr_this_cause,
+	&dev_attr_next_cause,
+};
+
+static int rstcause_probe(struct platform_device *pdev)
+{
+	struct of_phandle_args args;
+	struct cap_rstdev *rdev;
+	struct regmap *regs;
+	int r, i;
+
+	if (g_rdev)
+		return -ENODEV;
+
+	r = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+					     "pensando,causeregs", 1, 0, &args);
+	if (r) {
+		dev_err(&pdev->dev, "could not find causeregs\n");
+		return r;
+	}
+
+	regs = syscon_node_to_regmap(args.np);
+	if (IS_ERR(regs)) {
+		dev_err(&pdev->dev, "could not map causeregs\n");
+		return PTR_ERR(regs);
+	}
+
+	rdev = devm_kzalloc(&pdev->dev, sizeof(*rdev), GFP_KERNEL);
+	if (!rdev)
+		return -ENOMEM;
+	rdev->pdev = pdev;
+	platform_set_drvdata(pdev, rdev);
+
+	rdev->regs = regs;
+	rdev->regs_offset = args.args[0];
+	rdev->reboot_nb.notifier_call = rstcause_reboot_handler;
+	register_reboot_notifier(&rdev->reboot_nb);
+
+	rdev->panic_nb.notifier_call = rstcause_panic_handler;
+	atomic_notifier_chain_register(&panic_notifier_list, &rdev->panic_nb);
+
+	rdev->this_cause = read_cause_reg(rdev);
+
+	g_rdev = rdev;
+
+	rdev->pensando_kobj = pensando_fw_kobj_get();
+	if (rdev->pensando_kobj) {
+		for (i = 0; i < ARRAY_SIZE(rstcause_attrs); i++) {
+			r = device_create_file(&pdev->dev, rstcause_attrs[i]);
+			if (r) {
+				dev_err(&pdev->dev,
+					"failed to create sysfs file\n");
+				return r;
+			}
+		}
+		r = sysfs_create_link(rdev->pensando_kobj,
+				      &pdev->dev.kobj, "rstcause");
+		if (r) {
+			dev_err(&pdev->dev, "failed to create sysfs symlink\n");
+			kobject_put(rdev->pensando_kobj);
+			rdev->pensando_kobj = NULL;
+		}
+	}
+	return 0;
+}
+
+static int rstcause_remove(struct platform_device *pdev)
+{
+	struct cap_rstdev *rdev = platform_get_drvdata(pdev);
+
+	unregister_reboot_notifier(&rdev->reboot_nb);
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+					 &rdev->panic_nb);
+	if (g_rdev == rdev) {
+		g_rdev = NULL;
+		if (rdev->pensando_kobj)
+			kobject_put(rdev->pensando_kobj);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id rstcause_of_match[] = {
+	{.compatible = "pensando,rstcause"},
+	{ /* end of table */ }
+};
+
+static struct platform_driver rstcause_driver = {
+	.probe = rstcause_probe,
+	.remove = rstcause_remove,
+	.driver = {
+		   .name = "pensando-rstcause",
+		   .owner = THIS_MODULE,
+		   .of_match_table = rstcause_of_match,
+		   },
+};
+
+module_platform_driver(rstcause_driver);
+MODULE_DESCRIPTION("Pensando SoC Reset Cause Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/pensando/cap_rstcause.h b/drivers/soc/pensando/cap_rstcause.h
new file mode 100644
index 000000000000..7807770a4d75
--- /dev/null
+++ b/drivers/soc/pensando/cap_rstcause.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_RSTCAUSE_H__
+#define __CAP_RSTCAUSE_H__
+
+#define CAP_RSTCAUSE_EV_REBOOT		BIT(0)
+#define CAP_RSTCAUSE_EV_PANIC		BIT(1)
+#define CAP_RSTCAUSE_EV_PCIE_RESET	BIT(2)
+
+void cap_rstcause_set(u32 mask);
+
+#endif
diff --git a/drivers/soc/pensando/cap_soc.c b/drivers/soc/pensando/cap_soc.c
new file mode 100644
index 000000000000..b92c064970e3
--- /dev/null
+++ b/drivers/soc/pensando/cap_soc.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/export.h>
+#include <linux/kobject.h>
+
+#ifdef CONFIG_ARCH_PENSANDO_CAPRI_SOC
+DEFINE_SPINLOCK(apb_bus_spinlock);
+EXPORT_SYMBOL_GPL(apb_bus_spinlock);
+#endif
+
+static struct kobject *pensando_fw_kobj;
+struct kobject *pensando_fw_kobj_get(void);
+
+/*
+ * Creates a new pensando sysfs node if it does not exists. The kobj is
+ * returned after incrementing the refcnt, so a module should use kobject_put()
+ * when it is done using this koject.
+ */
+struct kobject *pensando_fw_kobj_get(void)
+{
+	if (!pensando_fw_kobj) {
+		pensando_fw_kobj = kobject_create_and_add("pensando", firmware_kobj);
+		if (!pensando_fw_kobj)
+			return NULL;
+	}
+	return kobject_get(pensando_fw_kobj);
+}
+EXPORT_SYMBOL_GPL(pensando_fw_kobj_get);
diff --git a/drivers/soc/pensando/cap_tracepoint.h b/drivers/soc/pensando/cap_tracepoint.h
new file mode 100644
index 000000000000..17510958d648
--- /dev/null
+++ b/drivers/soc/pensando/cap_tracepoint.h
@@ -0,0 +1,175 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM pensando
+
+#if !defined(_CAP_TRACEPOINT_H_) || defined(TRACE_HEADER_MULTI_READ)
+#define _CAP_TRACEPOINT_H_
+
+#include <linux/tracepoint.h>
+#include <linux/mm_types.h>
+
+DECLARE_EVENT_CLASS(cap_mem_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, vm_start)
+		__field(unsigned long, vm_end)
+		__field(unsigned long, va)
+		__field(unsigned long, pa)
+	),
+
+	TP_fast_assign(
+		__entry->vm_start = vma->vm_start;
+		__entry->vm_end = vma->vm_end;
+		__entry->va = vmf->address;
+		__entry->pa = vmf->pgoff << PAGE_SHIFT;
+	),
+
+	TP_printk("vm_start 0x%lx vm_end 0x%lx va 0x%lx pa 0x%lx",
+		__entry->vm_start,
+		__entry->vm_end,
+		__entry->va,
+		__entry->pa
+	)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_fault_enter,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_fault_exit,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pte_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pmd_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pud_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DECLARE_EVENT_CLASS(cap_mem_get_unmapped_area,
+
+TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+	TP_ARGS(va, len, pgoff, align),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, va)
+		__field(unsigned long, len)
+		__field(unsigned long, pa)
+		__field(unsigned long, align)
+	),
+
+	TP_fast_assign(
+		__entry->va = va;
+		__entry->len = len;
+		__entry->pa = pgoff << PAGE_SHIFT;
+		__entry->align = align;
+	),
+
+	TP_printk("vm_start 0x%lx vm_end 0x%lx pa 0x%lx align 0x%lx",
+		__entry->va,
+		__entry->va + __entry->len,
+		__entry->pa,
+		__entry->align
+	)
+);
+
+DEFINE_EVENT(cap_mem_get_unmapped_area, cap_mem_get_unmapped_area_enter,
+
+	TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+	TP_ARGS(va, len, pgoff, align)
+);
+
+DEFINE_EVENT(cap_mem_get_unmapped_area, cap_mem_get_unmapped_area_exit,
+
+	TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+	TP_ARGS(va, len, pgoff, align)
+);
+
+DECLARE_EVENT_CLASS(cap_mem_vmf_insert_pfn,
+
+TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, vm_start)
+		__field(unsigned long, vm_end)
+		__field(unsigned long, va)
+		__field(unsigned long, pa)
+	),
+
+	TP_fast_assign(
+		__entry->vm_start = vma->vm_start;
+		__entry->vm_end = vma->vm_end;
+		__entry->va = vmf->address;
+		__entry->pa = pa;
+	),
+
+	TP_printk("vm_start 0x%lx vm_end 0x%lx va 0x%lx pa 0x%lx",
+		__entry->vm_start,
+		__entry->vm_end,
+		__entry->va,
+		__entry->pa
+	)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pte,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pmd,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pud,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa)
+);
+
+#endif  /* !defined(_CAP_TRACEPOINT_H_) || defined(TRACE_HEADER_MULTI_READ) */
+
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE cap_tracepoint
+#include <trace/define_trace.h>
diff --git a/drivers/soc/pensando/capmem_dev.h b/drivers/soc/pensando/capmem_dev.h
new file mode 100644
index 000000000000..8ac07fd7b0e6
--- /dev/null
+++ b/drivers/soc/pensando/capmem_dev.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAPMEM_H__
+#define __CAPMEM_H__
+
+#define CAPMEM_NAME		"capmem"
+#define CAPMEM_DEV		"/dev/capmem"
+#define CAPMEM_IOCTL_NUM	0xcc
+
+struct capmem_range {
+	uint64_t	start;
+	uint64_t	len;
+	int		type;
+};
+enum {
+	CAPMEM_TYPE_DEVICE,
+	CAPMEM_TYPE_COHERENT,
+	CAPMEM_TYPE_NONCOHERENT,
+	/* CAPMEM_GET_RANGES2 */
+	CAPMEM_TYPE_BYPASS,
+};
+
+struct capmem_ranges_args {
+	struct capmem_range *range;
+	int nranges;
+};
+
+#define CAPMEM_MAX_RANGES	64
+
+#define CAPMEM_GET_NRANGES	_IOR(CAPMEM_IOCTL_NUM, 1, int)
+#define CAPMEM_GET_RANGES	_IOWR(CAPMEM_IOCTL_NUM, 2, struct capmem_ranges_args)
+#define CAPMEM_GET_RANGES2	_IOWR(CAPMEM_IOCTL_NUM, 3, struct capmem_ranges_args)
+
+#endif
diff --git a/drivers/soc/pensando/cmn_pmu_irq.c b/drivers/soc/pensando/cmn_pmu_irq.c
new file mode 100644
index 000000000000..2299611dc319
--- /dev/null
+++ b/drivers/soc/pensando/cmn_pmu_irq.c
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * AMD Pensando Salina SoC CMN PMU Interrupt Handler
+ *
+ * Copyright 2024 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+/*
+ * The cmn_pmu_int reg base/size region is a small mapping that includes the
+ * Salina CMN PMU CSR interrupt and AXI interrupt registers to initialize and
+ * service the CMN PMU interrupt.  Below are offsets to iomem base.
+ */
+#define SAL_CMN_PMU_CSR_CSR_INT         0x00
+#define SAL_CMN_PMU_CSR_NXCW_INTREG     0x20
+#define SAL_CMN_PMU_CSR_NXCW_INT_TEST   0x24
+#define SAL_CMN_PMU_CSR_NXCW_INT_ENABLE 0x28
+#define SAL_CMN_PMU_CSR_NXCW_INT_CLEAR  0x2c
+
+static irqreturn_t cmn_pmu_irq_handler(int irq, void *regs)
+{
+	writel(BIT(0), regs + SAL_CMN_PMU_CSR_NXCW_INTREG);
+	return IRQ_HANDLED;
+}
+
+static int salina_cmn_pmu_irq_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct resource res;
+	void __iomem *regs;
+	size_t res_size;
+	int irq, ret;
+
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret) {
+		pr_err("Failed to get memory resource\n");
+		return ret;
+	}
+	res_size = resource_size(&res);
+
+	if (!request_mem_region(res.start, res_size, "cmn_pmu_int")) {
+		pr_err("Failed to request memory region\n");
+		return -EBUSY;
+	}
+
+	regs = ioremap(res.start, res_size);
+	if (!regs) {
+		pr_err("Failed to remap memory region\n");
+		ret = -ENOMEM;
+		goto release_resource;
+	}
+
+	writel(GENMASK(13, 0), regs + SAL_CMN_PMU_CSR_NXCW_INT_CLEAR); /* Disable interrupts */
+	writel(GENMASK(13, 0), regs + SAL_CMN_PMU_CSR_NXCW_INTREG);    /* Ack interrupts */
+	writel(BIT(1), regs + SAL_CMN_PMU_CSR_CSR_INT);                /* Enable downstream int */
+	writel(BIT(0), regs + SAL_CMN_PMU_CSR_NXCW_INT_ENABLE);        /* Enable eMMC int */
+
+	irq = irq_of_parse_and_map(node, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev, "Failed to map interrupt\n");
+		ret = -ENXIO;
+		goto unmap_regs;
+	}
+
+	ret = request_irq(irq, cmn_pmu_irq_handler, IRQF_NOBALANCING | IRQF_NO_THREAD | IRQF_SHARED, "cmn_pmu_int", regs);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to request IRQ\n");
+		goto unmap_regs;
+	}
+	return 0;
+
+unmap_regs:
+	iounmap(regs);
+release_resource:
+	release_mem_region(res.start, res_size);
+	return ret;
+}
+
+static const struct of_device_id salina_cmn_pmu_irq_of_match[] = {
+	{ .compatible = "pensando,salina-cmn-pmu-interrupt" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, salina_cmn_pmu_irq_of_match);
+
+static struct platform_driver salina_cmn_pmu_irq = {
+	.probe = salina_cmn_pmu_irq_probe,
+	.driver = {
+		.name = "cmn_pmu_int",
+		.of_match_table = salina_cmn_pmu_irq_of_match,
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(salina_cmn_pmu_irq);
+
+MODULE_AUTHOR("Darshan Prajapati <darshan.prajapati@amd.com>");
+MODULE_DESCRIPTION("AMD Pensando Salina SoC CMN PMU IRQ Handler");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/pensando/kpci_constants.h b/drivers/soc/pensando/kpci_constants.h
new file mode 100644
index 000000000000..602da16a0277
--- /dev/null
+++ b/drivers/soc/pensando/kpci_constants.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+/*
+ * Layout of non-Linux Memory:
+ *  (base address provided in device tree and may change)
+ *  C500 0000  SHMEM segment (pciehw_shmem_t) [0x942440 bytes ~9.25Mb]
+ *  C5F0 0000  kpcimgr state (kstate_t)       [3 * 64k]
+ *  C5F3 0000  relocated code                 [Allow 256k]
+ *  C5F7 0000  available for stack when in nommu mode (64k)
+ *  C5F8 0000  top of stack
+ *  C5FF FFFF  end of 1M allotted range
+ */
+#define SHMEM_KSTATE_OFFSET       0xF00000
+#define SHMEM_KSTATE_SIZE          0x30000
+#define KSTATE_STACK_OFFSET        0x80000
+#define KSTATE_CODE_OFFSET      (SHMEM_KSTATE_OFFSET + SHMEM_KSTATE_SIZE)
+#define KSTATE_CODE_SIZE        (256 * 1024)
+#define KSTATE_MAGIC            0x1743BA1F
+
+/* size of trace data arrays */
+#define DATA_SIZE 100
+#define MSG_BUF_SIZE 32768
+
+/* uart and time related constants */
+#define PEN_UART 0x4800
+#define UART_THR 0
+#define UART_LSR 0x14
+#define DATA_READY 1
+#define OK_TO_WRITE 0x20
+#define UART_THRE_BIT 5
+
+/* phases */
+#define NOMMU 0
+#define NORMAL 1
+#define NUM_PHASES 2
+
+#define MSI_INDIRECT_IDX	0	/* indirect vector */
+#define MSI_NOTIFY_IDX		1	/* notify vector */
+#define MSI_NVECTORS		2
diff --git a/drivers/soc/pensando/kpcimgr.c b/drivers/soc/pensando/kpcimgr.c
new file mode 100644
index 000000000000..4f237f5ab5cf
--- /dev/null
+++ b/drivers/soc/pensando/kpcimgr.c
@@ -0,0 +1,902 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Kernel PCIE Manager Infrastructure
+ *
+ * This driver enables the relocation of module code to handle
+ * Pensando/Elba indirect PCIe transactions. The purpose is to allow
+ * code to persist and run during a kexec reboot. The loaded code runs
+ * in physical mode during arm64_relocate_new_kernel and also during
+ * the early boot phase before traditional driver code can run. This
+ * is all to provide extremely low latency response to indirect
+ * transactions, which must be serviced within 200ms.
+ *
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+
+#include "kpcimgr_api.h"
+#include "penpcie_dev.h"
+
+MODULE_LICENSE("GPL");
+
+kstate_t *kstate;
+DEFINE_SPINLOCK(kpcimgr_lock);
+static DECLARE_WAIT_QUEUE_HEAD(event_queue);
+
+void *kpci_memset(void *s, int c, size_t n);
+void kpcimgr_normal_poll(void);
+int contains_external_refs(struct module *mod, void *code_end);
+u64 kpcimgr_preg_read(u64 pa);
+unsigned long kpcimgr_get_entry(unsigned long old_entry, unsigned int cpu);
+
+void wake_up_event_queue(void)
+{
+	wake_up_interruptible(&event_queue);
+}
+
+/*
+ * We need our own memset/memcpy to avoid using
+ * any arm instructions that affect the memory cache.
+ * The memory used for kstate/code/etc is uncached.
+ */
+void *kpci_memset(void *s, int c, size_t n)
+{
+	if (((uintptr_t)s & 0x3) == 0 && (n & 0x3) == 0) {
+		u32 *p;
+		int i;
+
+		c &= 0xff;
+		c = ((c << 0) |
+		     (c << 8) |
+		     (c << 16) |
+		     (c << 24));
+		for (p = s, i = 0; i < n >> 2; i++, p++)
+			*p = c;
+	} else {
+		u8 *p;
+		int i;
+
+		for (p = s, i = 0; i < n; i++, p++)
+			*p = c;
+	}
+
+	return s;
+}
+
+void *kpci_memcpy(void *dst, const void *src, size_t n)
+{
+	u8 *d = dst;
+	const u8 *s = src;
+	int i;
+
+	for (i = 0; i < n; i++)
+		*d++ = *s++;
+
+	return dst;
+}
+
+/*
+ * Normal poll
+ */
+void kpcimgr_normal_poll(void)
+{
+	void (*poll_fn)(kstate_t *, int, int);
+	kstate_t *ks = get_kstate();
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpcimgr_lock, flags);
+	if (ks->valid == KSTATE_MAGIC) {
+		poll_fn = ks->code_base + ks->code_offsets[K_ENTRY_POLL];
+		poll_fn(ks, 0, NORMAL);
+	}
+	spin_unlock_irqrestore(&kpcimgr_lock, flags);
+}
+
+void kpcimgr_start_running(void)
+{
+	kstate_t *ks = get_kstate();
+	void (*init_fn)(kstate_t *ks);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpcimgr_lock, flags);
+	if (ks->valid == KSTATE_MAGIC) {
+		init_fn = ks->code_base + ks->code_offsets[K_ENTRY_INIT_INTR];
+		ks->running = 1;
+		init_fn(ks);
+	}
+	spin_unlock_irqrestore(&kpcimgr_lock, flags);
+}
+
+void kpcimgr_stop_running(void)
+{
+	kstate_t *ks = get_kstate();
+	void (*shut_fn)(int n);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpcimgr_lock, flags);
+	if (ks->valid == KSTATE_MAGIC) {
+		shut_fn = ks->code_base + ks->code_offsets[K_ENTRY_SHUT];
+		shut_fn(ks->active_port);
+	}
+	spin_unlock_irqrestore(&kpcimgr_lock, flags);
+
+	ks->running = 0;
+}
+
+/*
+ * Read event(s) from the event queue. Used by pciemgrd to find out
+ * about h/w event notifications that arrived during times when
+ * pciemgrd is not running (ie, during a kexec).
+ *
+ * Standard event queue semantics:
+ *  evq_head = index of slot used for next insertion
+ *  evq_tail = index of slot used for next removal
+ *  queue is empty when head == tail
+ *  queue is full when (head + 1) % queue_size == tail
+ *  queue is nearly full when (head + 2) % queue_size == tail
+ *
+ * Only tail is modified here, and the event handler only
+ * modifies head, so theoretically no race can exist between
+ * queue insertion/removal. The mutex is here only to
+ * cover the case of multiple readers.
+ */
+static ssize_t
+read_kpcimgr(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	static DEFINE_MUTEX(evq_lock);
+	kstate_t *ks = get_kstate();
+	char localmem[EVENT_SIZE];
+	ssize_t n = 0;
+	int tail;
+
+	mutex_lock(&evq_lock);
+	tail = ks->evq_tail;
+
+	while (nbytes >= EVENT_SIZE && ks->evq_head != tail) {
+		/*
+		 * intermediate copy since we cannot prevent copy_to_user
+		 * from doing cache operations
+		 */
+		kpci_memcpy(localmem, (void *)ks->evq[tail], EVENT_SIZE);
+
+		if (copy_to_user(buf + n, localmem, EVENT_SIZE)) {
+			mutex_unlock(&evq_lock);
+			return -EFAULT;
+		}
+
+		tail = (tail + 1) % EVENT_QUEUE_LENGTH;
+		n = n + EVENT_SIZE;
+		nbytes = nbytes - EVENT_SIZE;
+	}
+	ks->evq_tail = tail;
+	mutex_unlock(&evq_lock);
+
+	return n;
+}
+
+/*
+ * pciemgrd wants to select() on /dev/kpcimgr to discover
+ * if there are events in the event queue.
+ */
+static unsigned int
+poll_kpcimgr(struct file *file, poll_table *wait)
+{
+	kstate_t *ks = get_kstate();
+
+	poll_wait(file, &event_queue, wait);
+	if (ks->evq_head != ks->evq_tail)
+		return POLLIN | POLLRDNORM;
+	else
+		return 0;
+}
+
+static int mmap_kpcimgr(struct file *file, struct vm_area_struct *vma)
+{
+	phys_addr_t offset = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;
+	size_t size = vma->vm_end - vma->vm_start;
+	pgprot_t pgprot = vma->vm_page_prot;
+	kstate_t *ks = get_kstate();
+	unsigned long pfn, start;
+	void *pos;
+
+	if (offset + size > ks->shmem_size)
+		return -EINVAL;
+
+	if (ks->shmembase) {
+		pfn = (ks->shmembase + offset) >> PAGE_SHIFT;
+		pgprot = pgprot_device(pgprot);
+
+		if (!(file->f_flags & O_SYNC))
+			return -EINVAL;
+
+		pgprot = pgprot_writecombine(pgprot);
+		vma->vm_page_prot = pgprot;
+		if (remap_pfn_range(vma, vma->vm_start, pfn,
+				    size, vma->vm_page_prot))
+			return -EINVAL;
+	} else {
+		for (start = vma->vm_start, pos = ks->shmemva + offset;
+		     size > 0;
+		     start += PAGE_SIZE, pos += PAGE_SIZE, size -= PAGE_SIZE) {
+			pfn = vmalloc_to_pfn(pos);
+			if (remap_pfn_range(vma, start, pfn,
+					    PAGE_SIZE, vma->vm_page_prot))
+				return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Semantics of open(): if no code is loaded then open fails.
+ */
+static int open_kpcimgr(struct inode *inode, struct file *filp)
+{
+	kstate_t *ks = get_kstate();
+
+	if (ks->valid == KSTATE_MAGIC)
+		return 0;
+	else
+		return -ENODEV;
+}
+
+/*
+ * Examine code and look for calls (BL insn) and data references
+ * (ADRP) to memory addresses outside of the bounds of the module. If
+ * any are found, report them and return an error.
+ */
+int contains_external_refs(struct module *mod, void *code_end)
+{
+	char code_loc[KSYM_SYMBOL_LEN], target_ref[KSYM_SYMBOL_LEN];
+	struct module_memory *mod_mem_core_text;
+	int insn_count, call_count, adrp_count;
+	unsigned long start, size, target, insn_addr;
+	s32 offset;
+	u32 insn;
+
+	mod_mem_core_text = &mod->mem[MOD_TEXT];
+
+	start = (unsigned long)mod_mem_core_text->base;
+	size = (unsigned long)code_end - start;
+
+	for (insn_addr = start, insn_count = 0, call_count = 0, adrp_count = 0;
+	     insn_addr < start + size;
+	     insn_addr += sizeof(u32)) {
+		if (aarch64_insn_read((void *)insn_addr, &insn)) {
+			pr_err("Failed to read insn @ %lx\n", insn_addr);
+			return 1;
+		}
+		insn_count++;
+
+		if (aarch64_insn_is_bl(insn)) {
+			offset = aarch64_get_branch_offset(insn);
+			target = insn_addr + offset;
+
+			if (within_module(target, mod))
+				continue;
+
+			sprint_symbol(code_loc, insn_addr);
+			sprint_symbol(target_ref, target);
+			pr_err("Found call to %s at %s\n",
+			       target_ref, code_loc);
+
+			call_count++;
+		}
+
+		if (aarch64_insn_is_adrp(insn)) {
+			offset = aarch64_insn_adrp_get_offset(insn);
+			target = (insn_addr & PAGE_MASK) + offset;
+
+			if (within_module(target, mod))
+				continue;
+
+			sprint_symbol(code_loc, insn_addr);
+			sprint_symbol(target_ref, target);
+			pr_err("Found approximate reference to %s at %s\n",
+			       target_ref, code_loc);
+			pr_err(" (Please check object file for exact reference)\n");
+			adrp_count++;
+		}
+	}
+	pr_info("processed %d insns, %d extern calls, %d extern adrps\n",
+		insn_count, call_count, adrp_count);
+
+	if (call_count > 0 || adrp_count > 0)
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ * module_register
+ *
+ * Register module code/data to be used with kpcimgr. If requested, we
+ * relocate module code to "non-linux memory". The struct module
+ * pointer is not quite enough to do this, and we require a pointer
+ * to the end of the module code section. This is because we need to
+ * examine the code for certain instructions, and we don't want to
+ * look beyond the end of the code since that will be data which
+ * might contain values which just look like instructions.
+ *
+ * If the code contains no external references, then we can freely
+ * relocate the code repeatedly without relinking.
+ *
+ * We shut down service and then copy the module in its entirety to
+ * non-linux memory which we have previously mapped executable.
+ *
+ * We can also run with the module code unrelocated, but this is only
+ * for debugging, as it preserves the modules symbols in kallsyms, so
+ * any stack trace will show useful function names instead of raw hex
+ * addresses.
+ *
+ * After the copy, we restart the service if necessary.
+ */
+int kpcimgr_module_register(struct module *mod,
+			    struct kpcimgr_entry_points_t *ep, int relocate)
+{
+	struct module_memory *mod_mem_core_text;
+	void *code_end = ep->code_end;
+	kstate_t *ks = get_kstate();
+	unsigned long start_addr, iflags;
+	void (*init_fn)(kstate_t *ks);
+	void (*version_fn)(char **);
+	char *mod_buildtime;
+	int i, was_running, nentries;
+
+	mod_mem_core_text = &mod->mem[MOD_TEXT];
+
+	start_addr = (unsigned long)mod_mem_core_text->base;
+
+	if (ep->expected_mgr_version != KPCIMGR_KERNEL_VERSION
+#ifdef PEN_COMPAT_V2
+	    && ep->expected_mgr_version != 2
+#endif
+	   ) {
+		pr_info("KPCIMGR: '%s' expects kernel version %d, incompatible with version %d\n",
+			mod->name, ep->expected_mgr_version, KPCIMGR_KERNEL_VERSION);
+		return -EINVAL;
+	}
+
+	if (contains_external_refs(mod, code_end)) {
+		pr_err("KPCIMGR: relocation failed for '%s'\n", mod->name);
+		return -ENXIO;
+	}
+
+	if (mod_mem_core_text->size > KSTATE_CODE_SIZE) {
+		pr_err("KPCIMGR: module '%s' too large\n", mod->name);
+		return -EFBIG;
+	}
+
+	was_running = ks->running;
+	if (was_running) {
+		pr_info("%s: kpcimgr has stopped running\n", __func__);
+		kpcimgr_stop_running();
+	}
+	spin_lock_irqsave(&kpcimgr_lock, iflags);
+	ks->valid = 0;
+
+	if (ks->mod) {
+		module_put(ks->mod);
+		ks->mod = NULL;
+		ks->code_base = NULL;
+	}
+
+	if (ks->code_base)
+		module_memfree(ks->code_base);
+
+	if (relocate) {
+		ks->code_base = module_alloc(mod_mem_core_text->size);
+
+		if (ks->code_base == NULL) {
+			pr_err("KPCIMGR: module_alloc(%x)\n",
+			       mod_mem_core_text->size);
+			return -ENOMEM;
+		}
+		kpci_memcpy(ks->code_base, mod_mem_core_text->base,
+			    mod_mem_core_text->size);
+		flush_icache_range((long)ks->code_base,
+				   (long)ks->code_base + mod_mem_core_text->size);
+		set_memory_x((unsigned long)ks->code_base,
+			     mod_mem_core_text->size >> PAGE_SHIFT);
+	} else {
+		try_module_get(mod);
+		ks->mod = mod;
+		ks->code_base = mod_mem_core_text->base;
+	}
+	ks->code_size = mod_mem_core_text->size;
+
+#ifdef PEN_COMPAT_V2
+	nentries = ep->expected_mgr_version == 2 ? 7 : K_NUM_ENTRIES;
+#else
+	nentries = K_NUM_ENTRIES;
+#endif
+	for (i = 0; i < nentries; i++)
+		ks->code_offsets[i] = (unsigned long)ep->entry_point[i]
+			- start_addr;
+	for (; i < K_NUM_ENTRIES; i++)
+		ks->code_offsets[i] = 0;
+
+	if (ks->code_offsets[K_ENTRY_INIT_FN]) {
+		init_fn = ks->code_base + ks->code_offsets[K_ENTRY_INIT_FN];
+		init_fn(ks);
+	}
+
+	mod_buildtime = "";
+	if (ks->code_offsets[K_ENTRY_GET_VERSION]) {
+		version_fn = ks->code_base + ks->code_offsets[K_ENTRY_GET_VERSION];
+		version_fn(&mod_buildtime);
+	}
+
+	pr_info("KPCIMGR: module '%s: %s', start=%lx, end=%lx, size=%d\n",
+		mod->name, mod_buildtime, start_addr,
+		start_addr + mod_mem_core_text->size, mod_mem_core_text->size);
+
+	set_init_state(ks);
+	ks->valid = KSTATE_MAGIC;
+	ks->lib_version_major = ep->lib_version_major;
+	ks->lib_version_minor = ep->lib_version_minor;
+
+	spin_unlock_irqrestore(&kpcimgr_lock, iflags);
+	if (was_running) {
+		kpcimgr_start_running();
+		pr_info("%s: kpcimgr will begin running\n", __func__);
+	} else {
+		reset_stats(ks);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(kpcimgr_module_register);
+
+static void unmap_resources(void)
+{
+	kstate_t *ks = get_kstate();
+
+	int i;
+
+	for (i = 0; i < ks->nranges; i++) {
+		if (ks->mem_ranges[i].vaddr)
+			iounmap(ks->mem_ranges[i].vaddr);
+	}
+
+	if (ks->uart_addr)
+		iounmap(ks->uart_addr);
+
+	if (ks->have_persistent_mem) {
+		if (ks->persistent_base)
+			iounmap(ks->persistent_base);
+		if (ks->shmemva)
+			iounmap(ks->shmemva);
+		iounmap(ks);
+	} else {
+		vfree(ks->shmemva);
+		vfree((void *)ks);
+	}
+}
+
+static int map_resources(struct platform_device *pfdev)
+{
+	struct device_node *dn = pfdev->dev.of_node;
+	u32 shmem_idx, hwmem_idx;
+	struct resource res;
+	kstate_t *ks;
+	void *shmem;
+	int i, err;
+
+	err = of_property_read_u32(dn, "hwmem-index", &hwmem_idx);
+	if (err) {
+		pr_err("KPCIMGR: no hwmem-index value found\n");
+		return -ENOMEM;
+	}
+
+	err = of_property_read_u32(dn, "shmem-index", &shmem_idx);
+	if (err) {
+		pr_err("KPCIMGR: no shmem-index value found\n");
+		return -ENOMEM;
+	}
+
+	err = of_address_to_resource(dn, shmem_idx, &res);
+	if (err) {
+		pr_err("KPCIMGR: no resource found for shmem-index=%d\n",
+		       shmem_idx);
+		return -ENOMEM;
+	}
+
+	if (res.start == 0) {
+		/* indicates no persistent memory */
+		pr_info("KPCIMGR: no persistent memory\n");
+		ks = vmalloc(sizeof(kstate_t));
+		if (ks == NULL)
+			return -ENOMEM;
+		memset((void *)ks, 0, sizeof(kstate_t));
+		ks->active_port = -1;
+		ks->have_persistent_mem = 0;
+		shmem = vmalloc(resource_size(&res));
+		if (shmem == NULL) {
+			vfree((void *)ks);
+			return -ENOMEM;
+		}
+		ks->shmembase = 0;
+		ks->shmem_size = resource_size(&res);
+	} else {
+		if (resource_size(&res) > SHMEM_KSTATE_OFFSET) {
+			pr_err("KPCIMGR: shmem size overlaps kstate\n");
+			return -ENODEV;
+		}
+		shmem = ioremap(res.start, resource_size(&res));
+		if (shmem == NULL) {
+			pr_err("KPCIMGR: failed to map shmem\n");
+			return -ENODEV;
+		}
+
+		ks = ioremap(res.start + SHMEM_KSTATE_OFFSET, sizeof(kstate_t));
+		if (ks == NULL) {
+			pr_err("KPCIMGR: failed to map kstate\n");
+			iounmap(shmem);
+			return -ENOMEM;
+		}
+		if (ks->valid != KSTATE_MAGIC) {
+			kpci_memset((void *)ks, 0, sizeof(kstate_t));
+			ks->active_port = -1;
+		}
+
+		ks->have_persistent_mem = 1;
+		ks->shmembase = res.start;
+		ks->shmem_size = resource_size(&res);
+		pr_info("KPCIMGR: kstate mapped %llx at %lx\n",
+			res.start + SHMEM_KSTATE_OFFSET, (long)ks);
+
+		ks->persistent_base = ioremap(res.start + KSTATE_CODE_OFFSET,
+					      KSTATE_CODE_SIZE);
+		if (ks->persistent_base == NULL) {
+			pr_err("KPCIMGR: failed to map shmem code space\n");
+			goto errout;
+		}
+
+		if (ks->valid == KSTATE_MAGIC) {
+			ks->code_base = module_alloc(ks->code_size);
+			if (ks->code_base == NULL) {
+				pr_err("KPCIMGR: module_alloc(%lx) failed\n",
+				       ks->code_size);
+				goto errout;
+			}
+			kpci_memcpy(ks->code_base, ks->persistent_base,
+				    ks->code_size);
+			flush_icache_range((long)ks->code_base,
+					   (long)ks->code_base + KSTATE_CODE_SIZE);
+			set_memory_x((unsigned long)ks->code_base,
+				     ks->code_size >> PAGE_SHIFT);
+		}
+	}
+
+	kstate = ks;
+	ks->shmemva = shmem;
+
+	ks->uart_addr = ioremap(PEN_UART, 0x1000);
+	if (ks->uart_addr == NULL) {
+		pr_err("KPCIMGR: failed to map elba uart\n");
+		goto errout;
+	}
+	ks->driver_start_time = read_sysreg(cntvct_el0);
+
+	ks->nranges = 0;
+	for (i = 0; i < NUM_MEMRANGES; i++) {
+		struct mem_range_t *mr = &ks->mem_ranges[ks->nranges];
+
+		if (i == shmem_idx)
+			continue;
+
+		err = of_address_to_resource(dn, i, &res);
+		if (err)
+			break;
+
+		mr->base = res.start;
+		mr->end = res.start + resource_size(&res);
+		mr->vaddr = ioremap(res.start, resource_size(&res));
+		if (IS_ERR(mr->vaddr)) {
+			pr_err(PFX "iomap resource %d failed\n", i);
+			goto errout;
+		}
+		if (i == hwmem_idx)
+			ks->hwmem_idx = ks->nranges;
+		ks->nranges++;
+	}
+	return 0;
+
+ errout:
+	unmap_resources();
+	return -ENOMEM;
+}
+
+/*
+ * ISR for indirect transaction
+ */
+static irqreturn_t kpcimgr_indirect_intr(int irq, void *arg)
+{
+	int (*intr_fn)(kstate_t *, int);
+	kstate_t *ks = (kstate_t *)arg;
+	int port, r = 0;
+
+	spin_lock(&kpcimgr_lock);
+	if (ks->valid == KSTATE_MAGIC) {
+		ks->ind_intr++;
+		intr_fn = ks->code_base +
+			ks->code_offsets[K_ENTRY_INDIRECT_INTR];
+
+		port = ks->active_port;
+		if (port >= 0)
+			r = intr_fn(ks, port);
+	}
+	spin_unlock(&kpcimgr_lock);
+
+	return r ? IRQ_HANDLED : IRQ_NONE;
+}
+
+/*
+ * ISR for notify transaction
+ */
+static irqreturn_t kpcimgr_notify_intr(int irq, void *arg)
+{
+	int (*intr_fn)(kstate_t *, int);
+	kstate_t *ks = (kstate_t *)arg;
+	int port, r = 0;
+
+	spin_lock(&kpcimgr_lock);
+	if (ks->valid == KSTATE_MAGIC) {
+		ks->not_intr++;
+		intr_fn = ks->code_base + ks->code_offsets[K_ENTRY_NOTIFY_INTR];
+
+		port = ks->active_port;
+		if (port >= 0)
+			r = intr_fn(ks, port);
+	}
+	spin_unlock(&kpcimgr_lock);
+
+	return r ? IRQ_HANDLED : IRQ_NONE;
+}
+
+u64 kpcimgr_preg_read(u64 pa)
+{
+	u32 val;
+
+	pciep_regrd32((uint64_t)pa, &val);
+	return (u64)val;
+}
+
+static u64 kpcimgr_upcall(int req, u64 arg1, u64 arg2, u64 arg3)
+{
+	kstate_t *ks = get_kstate();
+
+	if (ks->valid != KSTATE_MAGIC)		/* no code loaded */
+		return 1;
+
+	switch (req) {
+	case WAKE_UP_EVENT_QUEUE:
+		ks->event_intr++;
+		wake_up_event_queue();
+		break;
+	case PRINT_LOG_MSG:
+		printk((char *)arg1); /* KERN_LEVEL provided by arg1 */
+		break;
+	case PREG_READ:
+		return kpcimgr_preg_read(arg1);
+	default:
+		return 1;
+	}
+	return 0;
+}
+
+static void set_msi_msg(struct msi_desc *desc, struct msi_msg *msg)
+{
+	kstate_t *ks = get_kstate();
+	struct msi_info *msi = &ks->msi[desc->msi_index];
+
+	msi->msgaddr = ((u64)msg->address_hi << 32) | msg->address_lo;
+	msi->msgdata = msg->data;
+}
+
+static void free_intrs(struct platform_device *pfdev)
+{
+	kstate_t *ks = get_kstate();
+	struct device *dev = &pfdev->dev;
+	struct msi_desc *desc;
+
+	msi_for_each_desc(desc, dev, MSI_DESC_ASSOCIATED)
+		free_irq(desc->irq, (void *)ks);
+
+	platform_msi_domain_free_irqs(&pfdev->dev);
+}
+
+struct {
+	irqreturn_t (*isr)(int irq, void *arg);
+	char *name;
+} kpcimgr_irq_table[] = {
+	{ kpcimgr_indirect_intr, "kpcimgr-indirect"},
+	{ kpcimgr_notify_intr,   "kpcimgr-notify"  },
+};
+
+static int alloc_intrs(struct platform_device *pfdev)
+{
+	irqreturn_t (*isr)(int irq, void *arg);
+	struct device *dev = &pfdev->dev;
+	kstate_t *ks = get_kstate();
+	struct msi_desc *desc;
+	char *name;
+	int r;
+
+	r = platform_msi_domain_alloc_irqs(dev, MSI_NVECTORS, set_msi_msg);
+	if (r)
+		return r;
+
+	msi_for_each_desc(desc, dev, MSI_DESC_ALL) {
+		isr = kpcimgr_irq_table[desc->msi_index].isr;
+		name = kpcimgr_irq_table[desc->msi_index].name;
+		r = devm_request_irq(dev, desc->irq, isr, 0, name, (void *)ks);
+		if (r)
+			goto err_out;
+	}
+	return 0;
+
+ err_out:
+	free_intrs(pfdev);
+	return r;
+}
+
+/*
+ * Called when a kexec is about to happen
+ */
+static int kpcimgr_notify_reboot(struct notifier_block *this,
+				 unsigned long code,
+				 void *unused)
+{
+	kstate_t *ks = get_kstate();
+	int was_running = ks->running;
+
+	/* stop running regardless of why a reboot is happening */
+	free_intrs(ks->pfdev);
+	if (was_running)
+		kpcimgr_stop_running();
+
+	if (!ks->code_base) {
+		pr_err("KPCIMGR: halting since no code is loaded\n");
+		ks->valid = 0;
+		return NOTIFY_DONE;
+	}
+
+	if (!ks->have_persistent_mem) {
+		pr_err("KPCIMGR: halting since code is not persistent\n");
+		ks->valid = 0;
+		return NOTIFY_DONE;
+	}
+
+	/* relocate code to "persistent" memory */
+	kpci_memcpy(ks->persistent_base, ks->code_base, ks->code_size);
+
+	if (code == SYS_DOWN) {
+		pr_err("KPCIMGR: going down at tick %lld\n",
+		       read_sysreg(cntvct_el0));
+
+		if (was_running)
+			ks->running = 1;
+
+		reset_stats(ks);
+		ks->ncalls = 0;
+		ks->kexec_time = read_sysreg(cntvct_el0);
+	}
+	return NOTIFY_DONE;
+}
+
+/*
+ * Driver Initialization
+ */
+static const struct file_operations __maybe_unused kpcimgr_fops = {
+	.owner          = THIS_MODULE,
+	.read           = read_kpcimgr,
+	.poll           = poll_kpcimgr,
+	.open           = open_kpcimgr,
+	.mmap           = mmap_kpcimgr,
+};
+
+static struct miscdevice kpcimgr_dev = {
+	MISC_DYNAMIC_MINOR,
+	KPCIMGR_NAME,
+	&kpcimgr_fops
+};
+
+static int kpcimgr_probe(struct platform_device *pfdev)
+{
+	kstate_t *ks;
+	int err;
+
+	err = map_resources(pfdev);
+	if (err)
+		goto errout;
+
+	ks = get_kstate();
+	ks->pfdev = pfdev;
+
+	err = alloc_intrs(ks->pfdev);
+	if (err) {
+		pr_err(PFX "alloc intrs: %d\n", err);
+		goto errout_unmap;
+	}
+
+	err = misc_register(&kpcimgr_dev);
+	if (err) {
+		pr_err(PFX "register pciemgr_dev failed: %d\n", err);
+		goto errout_free_intrs;
+	}
+
+	ks->upcall = (void *)kpcimgr_upcall;
+	ks->mod = NULL;
+	if (ks->valid == KSTATE_MAGIC && ks->running) {
+		kpcimgr_start_running();
+		kpcimgr_normal_poll();
+		pr_err("KPCIMGR: initialized and running.\n");
+	}
+	if (ks->have_persistent_mem) {
+		static struct notifier_block kpcimgr_nb = {
+			.notifier_call = kpcimgr_notify_reboot,
+			.next = NULL,
+			.priority = 0,
+		};
+		register_reboot_notifier(&kpcimgr_nb);
+	}
+
+	pr_info("KPCIMGR: kstate mapped at %lx, code at %lx\n",
+		(long)ks, (long)ks->code_base);
+
+	kpcimgr_sysfs_setup(pfdev);
+	return 0;
+
+ errout_free_intrs:
+	free_intrs(pfdev);
+
+ errout_unmap:
+	unmap_resources();
+
+ errout:
+	return err;
+}
+
+static const struct of_device_id kpcimgr_of_match[] = {
+	{ .compatible = "pensando,kpcimgr" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver kpcimgr_driver = {
+	.probe = kpcimgr_probe,
+	.driver = {
+		.name = "pensando-kpcimgr",
+		.owner = THIS_MODULE,
+		.of_match_table = kpcimgr_of_match,
+	},
+};
+builtin_platform_driver(kpcimgr_driver);
+
+/*
+ * Get entry point for pciesvc specific secondary cpu holding pen.
+ * Called from arch/arm64/kernel/smp_spin_table.c
+ * We choose the first cpu to arrive here. They will all try
+ * concurrently, but only one will be hijacked and the rest
+ * will go to their default holding pens.
+ */
+unsigned long kpcimgr_get_entry(unsigned long old_entry, unsigned int cpu)
+{
+	unsigned long (*entry_fn)(unsigned long entry, unsigned int cpu);
+	static DEFINE_SPINLOCK(choose_cpu_lock);
+	kstate_t *ks = get_kstate();
+	unsigned long entry;
+
+	if (ks == NULL || ks->valid != KSTATE_MAGIC ||
+	    !ks->running || !ks->have_persistent_mem)
+		return old_entry;
+
+	entry_fn = ks->code_base + ks->code_offsets[K_ENTRY_HOLDING_PEN];
+
+	spin_lock(&choose_cpu_lock);
+	entry = entry_fn(old_entry, cpu);
+	spin_unlock(&choose_cpu_lock);
+
+	return entry;
+}
diff --git a/drivers/soc/pensando/kpcimgr_api.h b/drivers/soc/pensando/kpcimgr_api.h
new file mode 100644
index 000000000000..6abf387a485b
--- /dev/null
+++ b/drivers/soc/pensando/kpcimgr_api.h
@@ -0,0 +1,174 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+#ifndef __KPCIMGR_API_H__
+#define __KPCIMGR_API_H__
+
+#ifdef __KERNEL__
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/reboot.h>
+#include <linux/poll.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/msi.h>
+#include <linux/mm.h>
+#include <linux/kallsyms.h>
+#include <linux/moduleloader.h>
+#include <linux/set_memory.h>
+#include <asm/cacheflush.h>
+#include <asm/insn.h>
+#endif
+
+#include "kpci_constants.h"
+
+#define K_ENTRY_INIT_INTR 0
+#define K_ENTRY_INIT_POLL 1
+#define K_ENTRY_SHUT 2
+#define K_ENTRY_POLL 3
+#define K_ENTRY_HOLDING_PEN 4
+#define K_ENTRY_INDIRECT_INTR 5
+#define K_ENTRY_NOTIFY_INTR 6
+#define K_ENTRY_INIT_FN 7
+#define K_ENTRY_CMD_READ 8
+#define K_ENTRY_CMD_WRITE 9
+#define K_ENTRY_GET_VERSION 10
+#define K_NUM_ENTRIES 16
+
+struct kpcimgr_entry_points_t {
+	int expected_mgr_version;
+	int lib_version_major;
+	int lib_version_minor;
+	void *code_end;
+	void *entry_point[K_NUM_ENTRIES];
+};
+
+/* upcalls */
+#define WAKE_UP_EVENT_QUEUE 1
+#define PRINT_LOG_MSG 2
+#define PREG_READ 3
+
+/* event queue sizing */
+#define EVENT_QUEUE_LENGTH 1024
+#define EVENT_SIZE 128
+
+/* max command size for sysfs cmd node */
+#define CMD_SIZE 4096
+
+/* max number of memory ranges from device tree */
+#define NUM_MEMRANGES 32
+
+struct kpcimgr_state_t {
+	/* essential state */
+	int valid;
+	int debug;
+	int running;
+	int active_port;
+	int have_persistent_mem;
+	int lib_version_major;
+	int lib_version_minor;
+
+	/* timestamps and general trace data */
+	long kexec_time;
+	long driver_start_time;
+	unsigned long trace_data[NUM_PHASES][DATA_SIZE];
+
+	/* virtual addresses */
+	void *uart_addr;
+	void *code_base;
+	void *persistent_base;
+	void *upcall;
+	void *pfdev;
+	void *shmemva;
+
+	unsigned long shmembase, shmem_size, code_size;
+	struct mem_range_t {
+		unsigned long base, end;
+		void *vaddr;
+	} mem_ranges[NUM_MEMRANGES];
+	int nranges;
+	int hwmem_idx;
+
+	/* interrupt vectors */
+	struct msi_info {
+		unsigned long msgaddr;
+		unsigned int msgdata;
+	} msi[MSI_NVECTORS];
+
+	/* stats for work done */
+	int ind_cfgrd, ind_cfgwr;
+	int ind_memrd, ind_memwr;
+	int ncalls;
+	int ind_intr, not_intr, event_intr;
+
+	int unused1[7];	/* was version=2 code_offsets[], keep evq* compat */
+
+	/* Event queue handling */
+	int evq_head, evq_tail;
+	char evq[EVENT_QUEUE_LENGTH][EVENT_SIZE];
+
+	/* debugging */
+	void *mod;
+	int msg_idx;
+	int cfgval;
+
+	/* offsets into relocated library code */
+	int code_offsets[K_NUM_ENTRIES];
+};
+
+typedef struct kpcimgr_state_t kstate_t;
+_Static_assert(sizeof(kstate_t) < SHMEM_KSTATE_SIZE,
+	       "kstate size insufficient");
+
+/* trace_data[] elements */
+#define FIRST_CALL_TIME 0
+#define FIRST_SEQNUM 1
+#define LAST_SEQNUM 2
+#define TAG 3
+#define PA_BAD_CNT 4
+#define NUM_CHECKS 5
+#define NUM_CALLS 6
+#define NUM_PENDINGS 7
+#define LAST_CALL_TIME 8
+#define EARLY_POLL 9
+#define MAX_DATA 10
+
+#define KPCIMGR_DEV "/dev/kpcimgr"
+#define KPCIMGR_NAME "kpcimgr"
+#define PFX KPCIMGR_NAME ": "
+#define KPCIMGR_KERNEL_VERSION 3
+
+#ifdef __KERNEL__
+int kpcimgr_module_register(struct module *mod,
+			    struct kpcimgr_entry_points_t *ep, int relocate);
+void kpcimgr_start_running(void);
+void kpcimgr_stop_running(void);
+void kpcimgr_sysfs_setup(struct platform_device *pfdev);
+void *kpci_memcpy(void *dst, const void *src, size_t n);
+void wake_up_event_queue(void);
+int aarch64_insn_read(void *addr, u32 *insnp);
+extern spinlock_t kpcimgr_lock;
+
+#define reset_stats(k) \
+	kpci_memset((void *)&(k)->trace_data[0][0], 0, sizeof((k)->trace_data))
+
+static inline void set_init_state(kstate_t *k)
+{
+	k->trace_data[NORMAL][FIRST_CALL_TIME] = 0;
+	k->ncalls = 0;
+}
+
+static inline kstate_t *get_kstate(void)
+{
+	extern kstate_t *kstate;
+	return kstate;
+}
+#endif
+
+#endif
diff --git a/drivers/soc/pensando/kpcimgr_sysfs.c b/drivers/soc/pensando/kpcimgr_sysfs.c
new file mode 100644
index 000000000000..fcee544a470c
--- /dev/null
+++ b/drivers/soc/pensando/kpcimgr_sysfs.c
@@ -0,0 +1,277 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Kernel PCIE Manager SYSFS functions
+ *
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+
+#include "kpcimgr_api.h"
+
+int kpcimgr_active_port;
+
+/* 'valid' read returns value of valid field */
+static ssize_t valid_show(struct device *dev,
+			  struct device_attribute *attr,
+			  char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	return sprintf(buf, "%x\n", ks->valid);
+}
+
+/* 'valid' write causes invalidation, regardless of value written */
+static ssize_t valid_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf,
+			   size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	if (ks->running) {
+		kpcimgr_stop_running();
+		pr_info("%s: kpcimgr has stopped running\n", __func__);
+	}
+	ks->valid = 0;
+	ks->debug = 0;
+	if (ks->mod) {
+		module_put(ks->mod);
+		ks->mod = NULL;
+		ks->code_base = NULL;
+	}
+
+	pr_info("%s: code unloaded\n", __func__);
+	return count;
+}
+
+static ssize_t running_show(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	return sprintf(buf, "%x\n", ks->running | ks->debug);
+}
+
+static ssize_t running_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf,
+			     size_t count)
+{
+	kstate_t *ks = get_kstate();
+	ssize_t rc;
+	long val;
+
+	rc = kstrtol(buf, 0, &val);
+	if (rc)
+		return rc;
+
+	if (!ks->valid)
+		return -EINVAL;
+
+	if (val == 0) {
+		if (ks->running) {
+			kpcimgr_stop_running();
+			pr_info("%s: kpcimgr has stopped polling\n", __func__);
+		}
+	} else {
+		if (ks->running) {
+			pr_info("%s: kpcimgr is already running\n", __func__);
+		} else {
+			ks->active_port = ffs(kpcimgr_active_port) - 1;
+			pr_info("%s: kpcimgr will begin running on port %d\n",
+				__func__, ks->active_port);
+			kpcimgr_start_running();
+		}
+		ks->debug = val & 0xfff0;
+	}
+
+	return count;
+}
+
+static ssize_t cfgval_show(struct device *dev,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	return sprintf(buf, "%x\n", ks->cfgval);
+}
+
+static ssize_t cfgval_store(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf,
+			    size_t count)
+{
+	kstate_t *ks = get_kstate();
+	ssize_t rc;
+	long val;
+
+	rc = kstrtol(buf, 0, &val);
+	if (rc)
+		return rc;
+
+	if (!ks->valid)
+		return -EINVAL;
+
+	ks->cfgval = val;
+	return count;
+}
+
+static ssize_t lib_version_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	if (!ks->valid)
+		return -ENODEV;
+
+	return sprintf(buf, "%d.%d\n", ks->lib_version_major,
+		       ks->lib_version_minor);
+}
+
+static ssize_t mgr_version_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	return sprintf(buf, "%d\n", KPCIMGR_KERNEL_VERSION);
+}
+
+static ssize_t command_read(struct file *file, struct kobject *kobj,
+			    struct bin_attribute *attr, char *out,
+			    loff_t off, size_t count)
+{
+	int (*cmd_read)(kstate_t *, char *, loff_t, size_t, int *);
+	kstate_t *ks = get_kstate();
+	int ret, success = 0;
+	unsigned long flags;
+
+	if (!ks->valid)
+		return -ENODEV;
+	if (ks->code_offsets[K_ENTRY_CMD_READ]) {
+		cmd_read = ks->code_base + ks->code_offsets[K_ENTRY_CMD_READ];
+		spin_lock_irqsave(&kpcimgr_lock, flags);
+		ret = cmd_read(ks, out, off, count, &success);
+		spin_unlock_irqrestore(&kpcimgr_lock, flags);
+	}
+	if (success)
+		return ret;
+	else
+		return 0;
+}
+
+static ssize_t command_write(struct file *filp, struct kobject *kobj,
+			     struct bin_attribute *bin_attr, char *buf,
+			     loff_t off, size_t count)
+{
+	int (*cmd_write)(kstate_t *, const char *, loff_t, size_t, int *);
+	kstate_t *ks = get_kstate();
+	int ret, success = 0;
+	unsigned long flags;
+
+	if (!ks->valid)
+		return -ENODEV;
+	if (ks->code_offsets[K_ENTRY_CMD_WRITE]) {
+		cmd_write = ks->code_base + ks->code_offsets[K_ENTRY_CMD_WRITE];
+		spin_lock_irqsave(&kpcimgr_lock, flags);
+		ret = cmd_write(ks, buf, off, count, &success);
+		spin_unlock_irqrestore(&kpcimgr_lock, flags);
+	}
+	if (success)
+		return ret;
+	else
+		return count;
+}
+
+/* event queue peek */
+static ssize_t event_queue_read(struct file *file, struct kobject *kobj,
+				struct bin_attribute *attr, char *out,
+				loff_t off, size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	/* is queue empty? */
+	if (ks->evq_head == ks->evq_tail)
+		return 0;
+
+	kpci_memcpy(out, (void *)ks->evq[ks->evq_tail], EVENT_SIZE);
+	return EVENT_SIZE;
+}
+
+/*
+ * This function is for testing. It injects an event onto the
+ * event queue, simulating an event notification from h/w.
+ */
+static ssize_t event_queue_write(struct file *filp, struct kobject *kobj,
+				 struct bin_attribute *bin_attr, char *buf,
+				 loff_t off, size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	if (count != EVENT_SIZE)
+		return -EINVAL;
+
+	if ((ks->evq_head + 1) % EVENT_QUEUE_LENGTH == ks->evq_tail)
+		return -ENOSPC;
+
+	kpci_memcpy((void *)ks->evq[ks->evq_head], buf, EVENT_SIZE);
+	ks->evq_head = (ks->evq_head + 1) % EVENT_QUEUE_LENGTH;
+	wake_up_event_queue();
+
+	return EVENT_SIZE;
+}
+
+static ssize_t kstate_read(struct file *file, struct kobject *kobj,
+			   struct bin_attribute *attr, char *out,
+			   loff_t off, size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	kpci_memcpy(out, (void *)ks + off, count);
+	return count;
+}
+
+static DEVICE_ATTR_RW(valid);
+static DEVICE_ATTR_RW(running);
+static DEVICE_ATTR_RW(cfgval);
+static DEVICE_ATTR_RO(lib_version);
+static DEVICE_ATTR_RO(mgr_version);
+static DEVICE_INT_ATTR(active_port, 0644, kpcimgr_active_port);
+static BIN_ATTR_RO(kstate, sizeof(kstate_t));
+static BIN_ATTR_RW(event_queue, EVENT_SIZE);
+static BIN_ATTR_RW(command, CMD_SIZE);
+
+static struct attribute *dev_attrs[] = {
+	&dev_attr_valid.attr,
+	&dev_attr_running.attr,
+	&dev_attr_cfgval.attr,
+	&dev_attr_active_port.attr.attr,
+	&dev_attr_lib_version.attr,
+	&dev_attr_mgr_version.attr,
+	NULL,
+};
+
+static struct bin_attribute *dev_bin_attrs[] = {
+	&bin_attr_kstate,
+	&bin_attr_event_queue,
+	&bin_attr_command,
+	NULL,
+};
+
+const struct attribute_group kpci_attr_group = {
+	.attrs = dev_attrs,
+	.bin_attrs = dev_bin_attrs,
+};
+
+void kpcimgr_sysfs_setup(struct platform_device *pfdev)
+{
+	if (sysfs_create_group(&pfdev->dev.kobj, &kpci_attr_group)) {
+		pr_err("KPCIMGR:sysfs_create_group failed\n");
+		return;
+	}
+
+	if (sysfs_create_link(kernel_kobj, &pfdev->dev.kobj, "kpcimgr")) {
+		pr_err("KPCIMGR: failed top create sysfs link\n");
+		return;
+	}
+}
diff --git a/drivers/soc/pensando/penfw.h b/drivers/soc/pensando/penfw.h
new file mode 100644
index 000000000000..fb6cfb772b7e
--- /dev/null
+++ b/drivers/soc/pensando/penfw.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __PENFW_H__
+#define __PENFW_H__
+
+enum penfw_opcodes {
+	PENFW_OP_GET_API_VER = 0,
+	PENFW_OP_GET_PENTRUST_STA,
+	PENFW_OP_SET_PENTRUST_UPG,
+	PENFW_OP_GET_BL1_STA,
+	PENFW_OP_SET_BL1_UPG,
+	PENFW_OP_GET_BL1_AR_NVCNTR,
+	PENFW_OP_COMMIT_BL1_AR_NVCNTR,
+	PENFW_OP_GET_BL31_SW_VER,
+	PENFW_OP_GET_BOOT_LCS,
+	PENFW_OP_GET_NEXT_LCS,
+	PENFW_OP_COMMIT_LCS_PROD,
+	PENFW_OP_GET_PENTRUST_VERSION,
+	PENFW_OP_GET_SERIAL_NUMBER,
+	PENFW_OP_GET_RANDOM,
+	PENFW_OP_GET_CHIP_CERT,
+	PENFW_OP_ATTEST_GET_TIME,
+	PENFW_OPCODE_MAX,
+};
+
+struct penfw_call_args {
+	int64_t a0;
+	uint64_t a1;
+	uint64_t a2;
+	uint64_t a3;
+	uint64_t a4;
+	uint64_t a5;
+};
+
+#define PENFW_NONCE_LEN 12
+#define PENFW_EC_SIG_SZ 96
+
+struct penfw_time_attestation {
+	struct {
+		uint32_t magic;
+		uint8_t nonce[PENFW_NONCE_LEN];
+		uint64_t time;
+	} data;
+	struct {
+		uint8_t	r[PENFW_EC_SIG_SZ / 2];
+		uint8_t	s[PENFW_EC_SIG_SZ / 2];
+	} signature;
+};
+
+
+#define PENFW_IOCTL_NUM  0xcd
+#define PENFW_FWCALL     _IOWR(PENFW_IOCTL_NUM, 1, struct penfw_call_args)
+
+void penfw_smc(struct penfw_call_args *args);
+
+#endif /* __PENFW_H__ */
diff --git a/drivers/soc/pensando/penfw_drv.c b/drivers/soc/pensando/penfw_drv.c
new file mode 100644
index 000000000000..d3b977db7d0f
--- /dev/null
+++ b/drivers/soc/pensando/penfw_drv.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/arm-smccc.h>
+
+#include "penfw.h"
+#include "penfw_sysfs.h"
+
+#define  DEVICE_NAME "penfw"
+#define  CLASS_NAME  "penfw"
+
+static int    majorNumber;
+static struct class *penfw_class;
+static struct device *penfw_dev;
+static DEFINE_MUTEX(penfw_mutex);
+
+void *penfwdata;
+phys_addr_t penfwdata_phys;
+
+static int penfw_open(struct inode *inodep, struct file *filep)
+{
+	return 0;
+}
+
+static long penfw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long ret = 0;
+	void __user *argp = (void __user *)arg;
+	struct penfw_call_args penfw_args_ob;
+
+	mutex_lock(&penfw_mutex);
+
+	if (copy_from_user(&penfw_args_ob, argp, sizeof(penfw_args_ob))) {
+		dev_err(penfw_dev, "copy from user failed\n");
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (cmd != PENFW_FWCALL) {
+		dev_err(penfw_dev, "received unsupported ioctl %u\n", cmd);
+		ret = -EOPNOTSUPP;
+		goto err;
+	}
+
+	penfw_smc(&penfw_args_ob);
+
+	// copy back data to user space struct
+	if (copy_to_user(argp, &penfw_args_ob, sizeof(penfw_args_ob))) {
+		dev_err(penfw_dev, "copy to user failed\n");
+		ret = -EFAULT;
+		goto err;
+	}
+
+err:
+	mutex_unlock(&penfw_mutex);
+
+	return ret;
+}
+
+static const struct file_operations fops = {
+	.open = penfw_open,
+	.unlocked_ioctl = penfw_ioctl
+};
+
+static int penfw_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	pr_info("penfw: initializing the device\n");
+	mutex_init(&penfw_mutex);
+	majorNumber = register_chrdev(0, DEVICE_NAME, &fops);
+	if (majorNumber < 0) {
+		pr_err("penfw: failed to register a major number\n");
+		return majorNumber;
+	}
+	pr_info("penfw: registered correctly with major number %d\n",
+			 majorNumber);
+
+	// register the device class
+	penfw_class = class_create(CLASS_NAME);
+	if (IS_ERR(penfw_class)) {
+		unregister_chrdev(majorNumber, DEVICE_NAME);
+		pr_err("penfw: failed to register device class\n");
+		return PTR_ERR(penfw_class);
+	}
+	pr_info("penfw: device class registered correctly\n");
+
+	// register the device driver
+	penfw_dev = device_create(penfw_class, NULL, MKDEV(majorNumber, 0),
+				  NULL, DEVICE_NAME);
+	if (IS_ERR(penfw_dev)) {
+		class_destroy(penfw_class);
+		unregister_chrdev(majorNumber, DEVICE_NAME);
+		dev_err(penfw_dev, "failed to create the device\n");
+		return PTR_ERR(penfw_dev);
+	}
+	dev_info(penfw_dev, "device class created correctly\n");
+
+	ret = penfw_sysfs_init(penfw_dev);
+	if (ret != 0) {
+		dev_err(penfw_dev, "penfw sys initialization failed\n");
+		return -1;
+	}
+	dev_info(penfw_dev, "penfw sys initialization success\n");
+
+	// Allocate memory for smc calls
+	penfwdata = (struct penfw_data *)devm_get_free_pages(penfw_dev,
+									GFP_KERNEL | GFP_ATOMIC, 0);
+	if (penfwdata == NULL) {
+		dev_err(penfw_dev, "penfw memory allocation failed\n");
+		return -1;
+	}
+
+	penfwdata_phys = virt_to_phys(penfwdata);
+
+	return 0;
+}
+
+static int penfw_remove(struct platform_device *pd)
+{
+	mutex_destroy(&penfw_mutex);
+	device_destroy(penfw_class, MKDEV(majorNumber, 0));
+	class_unregister(penfw_class);
+	class_destroy(penfw_class);
+	unregister_chrdev(majorNumber, DEVICE_NAME);
+	penfw_sysfs_deinit();
+	pr_info("penfw: Exiting!\n");
+
+	return 0;
+}
+
+static struct of_device_id penfw_of_match[] = {
+	{ .compatible = "pensando,penfw" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver penfw_driver = {
+	.probe = penfw_probe,
+	.remove = penfw_remove,
+	.driver = {
+		.name = "penfw",
+		.owner = THIS_MODULE,
+		.of_match_table = penfw_of_match,
+	},
+};
+
+module_platform_driver(penfw_driver);
diff --git a/drivers/soc/pensando/penfw_smc.c b/drivers/soc/pensando/penfw_smc.c
new file mode 100644
index 000000000000..b923b285f3bb
--- /dev/null
+++ b/drivers/soc/pensando/penfw_smc.c
@@ -0,0 +1,212 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/string.h>
+#include <linux/arm-smccc.h>
+#include <linux/printk.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+
+#include "penfw.h"
+
+#define PENFW_CALL_FID			    0xC2000002
+
+extern void *penfwdata;
+extern phys_addr_t penfwdata_phys;
+void penfw_smc_get_chip_cert(struct penfw_call_args *args);
+void penfw_smc_attest_get_time(struct penfw_call_args *args);
+
+static const char *_opcode_to_str(uint8_t opcode)
+{
+	switch (opcode) {
+	case PENFW_OP_GET_API_VER:
+		return "PENFW_OP_GET_API_VER";
+	case PENFW_OP_GET_PENTRUST_STA:
+		return "PENFW_OP_GET_PENTRUST_STA";
+	case PENFW_OP_SET_PENTRUST_UPG:
+		return "PENFW_OP_SET_PENTRUST_UPG";
+	case PENFW_OP_GET_BL1_STA:
+		return "PENFW_OP_GET_BL1_STA";
+	case PENFW_OP_SET_BL1_UPG:
+		return "PENFW_OP_SET_BL1_UPG";
+	case PENFW_OP_GET_BL1_AR_NVCNTR:
+		return "PENFW_OP_GET_BL1_AR_NVCNTR";
+	case PENFW_OP_COMMIT_BL1_AR_NVCNTR:
+		return "PENFW_OP_COMMIT_BL1_AR_NVCNTR";
+	case PENFW_OP_GET_BL31_SW_VER:
+		return "PENFW_OP_GET_BL31_SW_VER";
+	case PENFW_OP_GET_BOOT_LCS:
+		return "PENFW_OP_GET_BOOT_LCS";
+	case PENFW_OP_GET_NEXT_LCS:
+		return "PENFW_OP_GET_NEXT_LCS";
+	case PENFW_OP_COMMIT_LCS_PROD:
+		return "PENFW_OP_COMMIT_LCS_PROD";
+	case PENFW_OP_GET_PENTRUST_VERSION:
+		return "PENFW_OP_GET_PENTRUST_VERSION";
+	case PENFW_OP_GET_SERIAL_NUMBER:
+		return "PENFW_OP_GET_SERIAL_NUMBER";
+	case PENFW_OP_GET_RANDOM:
+		return "PENFW_OP_GET_RANDOM";
+	case PENFW_OP_GET_CHIP_CERT:
+		return "PENFW_OP_GET_CHIP_CERT";
+	case PENFW_OP_ATTEST_GET_TIME:
+		return "PENFW_OP_ATTEST_GET_TIME";
+	default:
+		return "PENFW_OP_UNKNOWN";
+	}
+}
+
+/*
+ * a1 = smc op (PENFW_OP_GET_CHIP_CERT)
+ * a2 = user buffer pointer to save the cert
+ * a3 = length of the user buf to get the chip cert
+ */
+void penfw_smc_get_chip_cert(struct penfw_call_args *args)
+{
+	struct arm_smccc_res res = {0};
+	uint8_t *chip_cert = NULL;
+	phys_addr_t cert_phys = 0;
+	uint32_t cert_len = 0;
+	uint32_t user_cert_len = args->a3;
+	void __user *user_cert = (void __user *)args->a2;
+
+	if ((user_cert_len != 0) && (user_cert_len > PAGE_SIZE)) {
+		args->a0 = -1;
+		return;
+	}
+
+	chip_cert = (uint8_t *)penfwdata;
+	cert_phys = penfwdata_phys;
+
+	if (user_cert_len)
+		cert_len = PAGE_SIZE;
+
+	arm_smccc_smc(PENFW_CALL_FID, PENFW_OP_GET_CHIP_CERT, cert_phys,
+					cert_len, 0, 0, 0, 0, &res);
+
+	if (res.a1 > PAGE_SIZE) {
+		args->a0 = -1;
+		return;
+	}
+
+	if (user_cert_len) {
+		if (res.a1 > user_cert_len) {
+			args->a0 = -1;
+			return;
+		}
+		if (copy_to_user(user_cert, chip_cert, res.a1)) {
+			args->a0 = -1;
+			return;
+		}
+	}
+
+	/* zero-out chip-cert after copying to userspace */
+	memset(penfwdata, 0, PAGE_SIZE);
+
+	args->a0 = res.a0;
+	args->a1 = res.a1;
+	args->a2 = res.a2;
+}
+
+/*
+ * a1 = smc op (PENFW_OP_ATTEST_GET_TIME)
+ * a2 = pointer to user provided nonce.
+ * a3 = length of nonce (must be 12 bytes)
+ * a4 = pointer to user buffer for attestation data.
+ * a5 = length of user attestation buffer
+ */
+void penfw_smc_attest_get_time(struct penfw_call_args *args)
+{
+	struct penfw_time_attestation *attp;
+	struct arm_smccc_res res = {0};
+	void __user *user_ta = (void  __user *)args->a4;
+	uint8_t *nonce;
+	phys_addr_t nonce_phys = 0, att_phys;
+
+	nonce = (uint8_t *)penfwdata;
+	nonce_phys = penfwdata_phys;
+
+	attp = (struct penfw_time_attestation *)(penfwdata + PENFW_NONCE_LEN);
+	att_phys = penfwdata_phys + PENFW_NONCE_LEN;
+
+	if (args->a3 != PENFW_NONCE_LEN) {
+		args->a0 = -1;
+		return;
+	}
+
+	if (args->a5 < sizeof(struct penfw_time_attestation)) {
+		args->a0 = -1;
+		return;
+	}
+
+	if (copy_from_user(nonce, (void *)args->a2, PENFW_NONCE_LEN)) {
+		args->a0 = -1;
+		return;
+	}
+
+	arm_smccc_smc(PENFW_CALL_FID, PENFW_OP_ATTEST_GET_TIME,
+		(uint64_t)nonce_phys, PENFW_NONCE_LEN,
+		(uint64_t)att_phys, sizeof(*attp), 0, 0, &res);
+
+	if (res.a0 == 0) {
+		if (copy_to_user(user_ta, attp, sizeof(*attp))) {
+			args->a0 = -5;
+			return;
+		}
+	}
+
+	args->a0 = res.a0;
+	args->a1 = res.a1;
+	args->a2 = res.a2;
+	args->a3 = res.a3;
+
+	/* zero out nonce and attestation data after copying to userspace */
+	memset(penfwdata, 0, PAGE_SIZE);
+}
+
+void penfw_smc(struct penfw_call_args *args)
+{
+	struct arm_smccc_res res = {0};
+
+	pr_debug("penfw: smc call for fn: %s\n",
+		 _opcode_to_str(args->a1));
+
+	switch (args->a1) {
+	case PENFW_OP_GET_API_VER:
+	case PENFW_OP_GET_PENTRUST_STA:
+	case PENFW_OP_SET_PENTRUST_UPG:
+	case PENFW_OP_GET_BL1_STA:
+	case PENFW_OP_SET_BL1_UPG:
+	case PENFW_OP_GET_BL1_AR_NVCNTR:
+	case PENFW_OP_COMMIT_BL1_AR_NVCNTR:
+	case PENFW_OP_GET_BL31_SW_VER:
+	case PENFW_OP_GET_BOOT_LCS:
+	case PENFW_OP_GET_NEXT_LCS:
+	case PENFW_OP_COMMIT_LCS_PROD:
+	case PENFW_OP_GET_PENTRUST_VERSION:
+	case PENFW_OP_GET_SERIAL_NUMBER:
+	case PENFW_OP_GET_RANDOM:
+		arm_smccc_smc(PENFW_CALL_FID, args->a1, args->a2, args->a3, 0, 0,
+						0, 0, &res);
+		// copy return vals
+		args->a0 = res.a0;
+		args->a1 = res.a1;
+		args->a2 = res.a2;
+		args->a3 = res.a3;
+		break;
+	case PENFW_OP_GET_CHIP_CERT:
+		penfw_smc_get_chip_cert(args);
+		break;
+	case PENFW_OP_ATTEST_GET_TIME:
+		penfw_smc_attest_get_time(args);
+		break;
+	default:
+		break;
+	}
+
+	pr_debug("penfw: smc return a0: 0x%llx a1: 0x%llx "\
+		 "a2: 0x%llx a3: 0x%llx\n", args->a0, args->a1,
+		 args->a2, args->a3);
+}
diff --git a/drivers/soc/pensando/penfw_sysfs.c b/drivers/soc/pensando/penfw_sysfs.c
new file mode 100644
index 000000000000..1e333240ad12
--- /dev/null
+++ b/drivers/soc/pensando/penfw_sysfs.c
@@ -0,0 +1,443 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/module.h>
+
+#include "penfw_sysfs.h"
+#include "penfw.h"
+
+extern struct kobject *pensando_fw_kobj_get(void);
+
+static struct kobject *pensando_kobj;
+static struct kobject *penfw_kobject;
+static struct kobject *pentrust_kobject;
+static struct kobject *bl1_kobject;
+static struct kobject *bl31_kobject;
+static struct kobject *lifecycle_kobject;
+
+static ssize_t pentrust_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_PENTRUST_STA;
+	penfw_smc(&args);
+
+	if (args.a0 < 0)
+		return sprintf(buf, "Error\n");
+
+	if (!strcmp(attr->attr.name, "version"))
+		return sprintf(buf, "%llu\n", (args.a0 & 0xffffffff));
+	else if (!strcmp(attr->attr.name, "upgrade"))
+		return sprintf(buf, "%llu\n", (args.a1 >> 1) & 1);
+	else if (!strcmp(attr->attr.name, "image_slot"))
+		return sprintf(buf, "%llu\n", (args.a1 & 1));
+	else
+		return sprintf(buf, "\n");
+}
+
+static ssize_t pentrust_show_version(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	struct penfw_call_args args = {0};
+	int major, minor1, minor2;
+
+	args.a1 = PENFW_OP_GET_PENTRUST_VERSION;
+	penfw_smc(&args);
+
+	if (args.a0 < 0)
+		return sprintf(buf, "Error\n");
+
+	if (!strcmp(attr->attr.name, "sw_version")) {
+		major = args.a1 >> 32;
+		minor1 = (args.a1 & 0xffff0000) >> 16;
+		minor2 = args.a1 & 0xffff;
+		return sprintf(buf, "%d.%d.%d\n", major, minor1, minor2);
+	} else if (!strcmp(attr->attr.name, "crypto_version")) {
+		major = args.a2 >> 32;
+		minor1 = (args.a2 & 0xffff0000) >> 16;
+		minor2 = args.a2 & 0xffff;
+		return sprintf(buf, "%d.%d.%d\n", major, minor1, minor2);
+	} else {
+		return sprintf(buf, "\n");
+	}
+}
+
+static ssize_t pentrust_store(struct kobject *kobj, struct kobj_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct penfw_call_args args = {0};
+
+	if (strcmp(attr->attr.name, "upgrade") != 0)
+		return -1;
+
+	args.a1 = PENFW_OP_SET_PENTRUST_UPG;
+	penfw_smc(&args);
+	if (args.a0 < 0)
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t bl1_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_BL1_STA;
+	penfw_smc(&args);
+
+	if (args.a0 < 0)
+		return sprintf(buf, "Error\n");
+
+	if (!strcmp(attr->attr.name, "version"))
+		return sprintf(buf, "%llu\n", (args.a0 & 0xffffffff));
+	else if (!strcmp(attr->attr.name, "ar_version"))
+		return sprintf(buf, "%llu\n", ((args.a0 >> 32) & 0xff));
+	else if (!strcmp(attr->attr.name, "upgrade"))
+		return sprintf(buf, "%llu\n", (args.a1 >> 1) & 1);
+	else if (!strcmp(attr->attr.name, "image_slot"))
+		return sprintf(buf, "%llu\n", (args.a1 & 1));
+	else
+		return sprintf(buf, "\n");
+}
+
+static ssize_t bl1_ar_nvcntr_show(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_BL1_AR_NVCNTR;
+	penfw_smc(&args);
+
+	if (args.a0 < 0)
+		return sprintf(buf, "Error\n");
+
+	if (!strcmp(attr->attr.name, "ar_nv_cntr"))
+		return sprintf(buf, "%llu\n", (args.a0 & 0xffffffff));
+	else
+		return sprintf(buf, "\n");
+}
+
+static ssize_t bl1_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct penfw_call_args args = {0};
+
+	if (strcmp(attr->attr.name, "upgrade") != 0)
+		return -1;
+
+	args.a1 = PENFW_OP_SET_BL1_UPG;
+	penfw_smc(&args);
+	if (args.a0 < 0)
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t bl31_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	struct penfw_call_args args = {0};
+	char vers[256];
+	uint64_t val;
+	int byte, shift;
+
+	args.a1 = PENFW_OP_GET_BL31_SW_VER;
+	penfw_smc(&args);
+
+	if (args.a0 < 0)
+		return -EIO;
+
+	for (byte = 0; byte < 256 - 1; byte++) {
+		if ((byte / 8) == 0)
+			val = args.a0;
+		else if ((byte / 8) == 1)
+			val = args.a1;
+		else if ((byte / 8) == 2)
+			val = args.a2;
+		else
+			val = args.a3;
+
+		shift = (byte * 8) % 64;
+		vers[byte] = (val >> (shift)) & 0x7f;
+		if (vers[byte] == 0)
+			break;
+	}
+	vers[255] = 0;
+
+	return sprintf(buf, "%s\n", vers);
+}
+
+static const char *_lcs_to_str(int lcs_state)
+{
+	switch (lcs_state) {
+	case 0:
+		return "disabled";
+	case 1:
+		return "open";
+	case 2:
+		return "soft_prod";
+	case 3:
+		return "prod";
+	case 4:
+		return "rip";
+	default:
+		return "unknown";
+	}
+}
+
+static ssize_t boot_lcs_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_BOOT_LCS;
+	penfw_smc(&args);
+
+	if (args.a0 < 0)
+		return sprintf(buf, "Error\n");
+
+	if (!strcmp(attr->attr.name, "boot_state"))
+		return sprintf(buf, "%s\n", _lcs_to_str(args.a0));
+	else
+		return sprintf(buf, "\n");
+}
+
+static ssize_t next_lcs_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_NEXT_LCS;
+	penfw_smc(&args);
+
+	if (args.a0 < 0)
+		return sprintf(buf, "Error\n");
+
+	if (!strcmp(attr->attr.name, "next_state"))
+		return sprintf(buf, "%s\n", _lcs_to_str(args.a0));
+	else
+		return sprintf(buf, "\n");
+}
+
+// pentrust attributes
+static struct kobj_attribute pentrust_attr_ver = __ATTR(version, 0400,
+							pentrust_show, NULL);
+static struct kobj_attribute pentrust_attr_img_slot = __ATTR(image_slot, 0400,
+							     pentrust_show,
+							     NULL);
+static struct kobj_attribute pentrust_attr_upg = __ATTR(upgrade, 0600,
+							pentrust_show,
+							pentrust_store);
+static struct kobj_attribute pentrust_attr_sw_ver = __ATTR(sw_version, 0400,
+							pentrust_show_version, NULL);
+
+static struct kobj_attribute pentrust_attr_crypto_ver = __ATTR(crypto_version, 0400,
+							pentrust_show_version, NULL);
+
+static struct attribute *pentrust_attrs[] = {
+	&pentrust_attr_ver.attr,
+	&pentrust_attr_img_slot.attr,
+	&pentrust_attr_upg.attr,
+	&pentrust_attr_sw_ver.attr,
+	&pentrust_attr_crypto_ver.attr,
+	NULL
+};
+
+static struct attribute_group pentrust_attr_group = {
+	.attrs = pentrust_attrs,
+};
+
+// bl1 attributes
+static struct kobj_attribute bl1_attr_ver = __ATTR(version, 0400, bl1_show,
+						   NULL);
+static struct kobj_attribute bl1_attr_ar_version = __ATTR(ar_version, 0400,
+							  bl1_show, NULL);
+static struct kobj_attribute bl1_attr_img_slot = __ATTR(image_slot, 0400,
+							bl1_show, NULL);
+static struct kobj_attribute bl1_attr_upg = __ATTR(upgrade, 0600, bl1_show,
+						   bl1_store);
+static struct kobj_attribute bl1_attr_ar_nv_cntr = __ATTR(ar_nv_cntr, 0400,
+							  bl1_ar_nvcntr_show,
+							  NULL);
+
+static struct attribute *bl1_attrs[] = {
+	&bl1_attr_ver.attr,
+	&bl1_attr_ar_version.attr,
+	&bl1_attr_img_slot.attr,
+	&bl1_attr_upg.attr,
+	&bl1_attr_ar_nv_cntr.attr,
+	NULL
+};
+
+static struct attribute_group bl1_attr_group = {
+	.attrs = bl1_attrs,
+};
+
+// bl31 attributes
+static struct kobj_attribute bl31_attr_sw_ver = __ATTR(sw_version, 0400,
+						       bl31_show, NULL);
+
+static struct attribute *bl31_attrs[] = {
+	&bl31_attr_sw_ver.attr,
+	NULL
+};
+
+static struct attribute_group bl31_attr_group = {
+	.attrs = bl31_attrs,
+};
+
+// lifecycle attributes
+static struct kobj_attribute lifecycle_attr_boot_state = __ATTR(boot_state,
+								0400,
+								boot_lcs_show,
+								NULL);
+static struct kobj_attribute lifecycle_attr_next_state = __ATTR(next_state,
+								0400,
+								next_lcs_show,
+								NULL);
+
+static struct attribute *lifecycle_attrs[] = {
+	&lifecycle_attr_boot_state.attr,
+	&lifecycle_attr_next_state.attr,
+	NULL
+};
+
+static struct attribute_group lifecycle_attr_group = {
+	.attrs = lifecycle_attrs,
+};
+
+
+int penfw_sysfs_init(struct device *penfwDevice)
+{
+	int ret = 0;
+
+	// /sys/firmware/pensando
+	pensando_kobj = pensando_fw_kobj_get();
+	if (!pensando_kobj) {
+		dev_err(penfwDevice, "Unable to create /sys/firmware/pensando"
+				     " node\n");
+		return -ENOMEM;
+	}
+
+	// /sys/firmware/pensando/penfw
+	penfw_kobject = kobject_create_and_add("penfw", pensando_kobj);
+	if (!penfw_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw node\n");
+		ret = -ENOMEM;
+		goto penfw_err;
+	}
+
+	// /sys/firmware/pensando/penfw/pentrust
+	pentrust_kobject = kobject_create_and_add("pentrust", penfw_kobject);
+	if (!pentrust_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/pentrust "
+				     "node\n");
+		ret = -ENOMEM;
+		goto pentrust_err;
+	}
+
+	if (sysfs_create_group(pentrust_kobject, &pentrust_attr_group)) {
+		dev_err(penfwDevice, "Unable to create pentrust attributes "
+				     "group\n");
+		ret = -1;
+		goto bl1_err;
+	}
+
+	// /sys/firmware/pensando/penfw/bl1
+	bl1_kobject = kobject_create_and_add("bl1", penfw_kobject);
+	if (!bl1_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/bl1 node\n");
+		ret = -ENOMEM;
+		goto bl1_err;
+	}
+
+	if (sysfs_create_group(bl1_kobject, &bl1_attr_group)) {
+		dev_err(penfwDevice, "Unable to create bl1 attributes group\n");
+		ret = -1;
+		goto bl31_err;
+	}
+
+	// /sys/firmware/pensando/penfw/bl31
+	bl31_kobject = kobject_create_and_add("bl31", penfw_kobject);
+	if (!bl31_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/bl31 "
+				     "node\n");
+		ret = -ENOMEM;
+		goto bl31_err;
+	}
+
+	if (sysfs_create_group(bl31_kobject, &bl31_attr_group)) {
+		dev_err(penfwDevice, "Unable to create bl31 attributes "
+				     "group\n");
+		ret = -1;
+		goto lifecycle_err;
+	}
+
+	// /sys/firmware/pensando/penfw/lifecycle
+	lifecycle_kobject = kobject_create_and_add("lifecycle", penfw_kobject);
+	if (!lifecycle_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/lifecycle "
+				     "node\n");
+		ret = -ENOMEM;
+		goto lifecycle_err;
+	}
+
+	if (sysfs_create_group(lifecycle_kobject, &lifecycle_attr_group)) {
+		dev_err(penfwDevice, "Unable to create lifecycle attributes "
+				     "group\n");
+		ret = -1;
+		goto lifecycle_attr_err;
+	}
+
+return ret;
+
+lifecycle_attr_err:
+	kobject_put(lifecycle_kobject);
+lifecycle_err:
+	kobject_put(bl31_kobject);
+bl31_err:
+	kobject_put(bl1_kobject);
+bl1_err:
+	kobject_put(pentrust_kobject);
+pentrust_err:
+	kobject_put(penfw_kobject);
+penfw_err:
+	kobject_put(pensando_kobj);
+
+	return ret;
+}
+
+int penfw_sysfs_deinit(void)
+{
+	if (lifecycle_kobject)
+		kobject_put(lifecycle_kobject);
+	if (bl31_kobject)
+		kobject_put(bl31_kobject);
+	if (bl1_kobject)
+		kobject_put(bl1_kobject);
+	if (pentrust_kobject)
+		kobject_put(penfw_kobject);
+	if (penfw_kobject)
+		kobject_put(penfw_kobject);
+	if (pensando_kobj)
+		kobject_put(pensando_kobj);
+
+	return 0;
+}
diff --git a/drivers/soc/pensando/penfw_sysfs.h b/drivers/soc/pensando/penfw_sysfs.h
new file mode 100644
index 000000000000..41debed5fd65
--- /dev/null
+++ b/drivers/soc/pensando/penfw_sysfs.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+#ifndef __PENFW_SYSFS_H__
+#define __PENFW_SYSFS_H__
+
+int penfw_sysfs_init(struct device *penfwDevice);
+int penfw_sysfs_deinit(void);
+
+#endif /* __PENFW_SYSFS_H__ */
diff --git a/drivers/soc/pensando/penpcie_dev.h b/drivers/soc/pensando/penpcie_dev.h
new file mode 100644
index 000000000000..5426d2edf516
--- /dev/null
+++ b/drivers/soc/pensando/penpcie_dev.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020-2022, Pensando Systems Inc.
+ */
+
+#ifndef __PENPCIE_DEV_H__
+#define __PENPCIE_DEV_H__
+
+#define PENPCIE_NAME		"penpcie"
+#define PENPCIE_DEV		"/dev/penpcie"
+
+struct pcie_rw {
+	uint64_t pciepa;
+	size_t size;
+	union {
+		void *rdvalp;
+		uint64_t wrval;
+	};
+};
+
+#define PCIE_IOCTL_NUM		'P'
+#define PCIE_PCIEP_REGRD	_IOWR(PCIE_IOCTL_NUM, 1, struct pcie_rw)
+
+int pciep_regrd32(const uint64_t pciepa, uint32_t *val);
+
+#endif
diff --git a/drivers/soc/pensando/sbus.c b/drivers/soc/pensando/sbus.c
new file mode 100644
index 000000000000..cc0e51d613a0
--- /dev/null
+++ b/drivers/soc/pensando/sbus.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright (c) 2022, Pensando Systems Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/ioctl.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#define MAX_DEVICES			4
+#define SBUS_SBUS_RST			0x20
+#define SBUS_SBUS_WR			0x21
+#define SBUS_SBUS_RD			0x22
+#define SBUS_INDIR_DATA_ADDR_LSB	8
+#define SBUS_INDIR_DATA_COMMAND_LSB	16
+
+static dev_t sbus_dev;
+static struct class *dev_class;
+static int dev_inst;
+
+struct sbus_ioctl_args {
+	u32 sbus_rcvr_addr;
+	u32 sbus_data_addr;
+	u32 sbus_data;
+};
+
+struct sbusdev_info {
+	struct platform_device *pdev;
+	void __iomem *sbus_indir;
+	void __iomem *sbus_dhs;
+	spinlock_t sbus_lock;
+	struct cdev cdev;
+};
+
+#define SBUS_WRITE	_IOW('a', 'a', struct sbus_ioctl_args)
+#define SBUS_READ	_IOWR('a', 'b', struct sbus_ioctl_args)
+#define SBUS_RESET	_IOW('a', 'c', struct sbus_ioctl_args)
+
+static int sbus_drv_open(struct inode *inode, struct file *file)
+{
+	struct sbusdev_info *sbus_ring;	/* device information */
+
+	sbus_ring = container_of(inode->i_cdev, struct sbusdev_info, cdev);
+	file->private_data = sbus_ring;
+	pr_debug("Device File Opened...!!\n");
+	return 0;
+}
+
+static void sbus_write(struct sbus_ioctl_args param,
+		       struct sbusdev_info *sbus_ring)
+{
+	uint32_t sbus_val;
+
+	sbus_val = param.sbus_rcvr_addr |
+		(param.sbus_data_addr << SBUS_INDIR_DATA_ADDR_LSB) |
+		(SBUS_SBUS_WR << SBUS_INDIR_DATA_COMMAND_LSB);
+
+	pr_debug("sbus_rcvr_addr %d sbus_data_addr %d sbus_data %d\n",
+	param.sbus_rcvr_addr, param.sbus_data_addr, param.sbus_data);
+
+	spin_lock(&sbus_ring->sbus_lock);
+
+	iowrite32(sbus_val, sbus_ring->sbus_indir);
+	iowrite32(param.sbus_data, sbus_ring->sbus_dhs);
+
+	spin_unlock(&sbus_ring->sbus_lock);
+}
+
+static uint32_t sbus_read(struct sbus_ioctl_args param,
+			  struct sbusdev_info *sbus_ring)
+{
+	uint32_t sbus_val, val;
+
+	sbus_val = param.sbus_rcvr_addr |
+		(param.sbus_data_addr << SBUS_INDIR_DATA_ADDR_LSB) |
+		(SBUS_SBUS_RD << SBUS_INDIR_DATA_COMMAND_LSB);
+
+	pr_debug("sbus_rcvr_addr %d sbus_data_addr %d\n",
+		param.sbus_rcvr_addr, param.sbus_data_addr);
+
+	spin_lock(&sbus_ring->sbus_lock);
+
+	iowrite32(sbus_val, sbus_ring->sbus_indir);
+	val = ioread32(sbus_ring->sbus_dhs);
+
+	spin_unlock(&sbus_ring->sbus_lock);
+
+	return val;
+}
+
+static void sbus_reset(struct sbus_ioctl_args param,
+		       struct sbusdev_info *sbus_ring)
+{
+	uint32_t sbus_val;
+
+	sbus_val = param.sbus_rcvr_addr |
+		(param.sbus_data_addr << SBUS_INDIR_DATA_ADDR_LSB) |
+		(SBUS_SBUS_RST << SBUS_INDIR_DATA_COMMAND_LSB);
+
+	pr_debug("sbus_rcvr_addr %d sbus_data_addr %d\n",
+		param.sbus_rcvr_addr, param.sbus_data_addr);
+
+	spin_lock(&sbus_ring->sbus_lock);
+
+	iowrite32(sbus_val, sbus_ring->sbus_indir);
+	iowrite32(0, sbus_ring->sbus_dhs);
+
+	spin_unlock(&sbus_ring->sbus_lock);
+}
+
+/*
+ * This function will be called when we write IOCTL on the Device file
+ */
+static long sbus_drv_ioctl(struct file *file, unsigned int cmd,
+			   unsigned long arg)
+{
+	struct sbusdev_info *sbus_ring = file->private_data;
+	struct sbus_ioctl_args param_ioctl;
+
+	switch (cmd) {
+	case SBUS_WRITE:
+		if (copy_from_user
+			(&param_ioctl, (struct sbus_ioctl_args *)arg,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		sbus_write(param_ioctl, sbus_ring);
+		break;
+	case SBUS_READ:
+		if (copy_from_user
+			(&param_ioctl, (struct sbus_ioctl_args *)arg,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		param_ioctl.sbus_data = sbus_read(param_ioctl, sbus_ring);
+		if (copy_to_user
+			((struct sbus_ioctl_args *)arg, &param_ioctl,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		break;
+	case SBUS_RESET:
+		if (copy_from_user
+			(&param_ioctl, (struct sbus_ioctl_args *)arg,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		sbus_reset(param_ioctl, sbus_ring);
+		break;
+	default:
+		return -ENOTTY;
+	}
+
+	return 0;
+}
+
+/*
+ * File operation structure
+ */
+static const struct file_operations fops = {
+	.open = sbus_drv_open,
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = sbus_drv_ioctl,
+};
+
+/*
+ * Module Init function
+ */
+static int sbus_probe(struct platform_device *pdev)
+{
+	int major, sbus_ring_num;
+	dev_t device;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct sbusdev_info *sbus_ring;
+
+	if (dev_inst > MAX_DEVICES-1)
+		return -ENODEV;
+
+	if (of_property_read_u32(pdev->dev.of_node, "sbus-ring-num",
+				&sbus_ring_num)) {
+		pr_debug("missing sbus-ring-num in device tree\n");
+		return -EINVAL;
+	}
+
+	sbus_ring = devm_kzalloc(dev, sizeof(*sbus_ring), GFP_KERNEL);
+	if (!sbus_ring)
+		return -ENOMEM;
+
+	sbus_ring->pdev = pdev;
+	platform_set_drvdata(pdev, sbus_ring);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sbus_ring->sbus_indir = devm_ioremap_resource(dev, res);
+	if (IS_ERR(sbus_ring->sbus_indir)) {
+		dev_err(dev, "Cannot remap sbus reg addresses.\n");
+		return PTR_ERR(sbus_ring->sbus_indir);
+	}
+	sbus_ring->sbus_dhs = sbus_ring->sbus_indir + 0x4;
+
+	spin_lock_init(&sbus_ring->sbus_lock);
+
+	pr_debug("sbus_indir %p sbus_dhs %p\n",
+			sbus_ring->sbus_indir, sbus_ring->sbus_dhs);
+
+	if (dev_inst == 0) {
+		/* Allocating Major number & reserving minor numbers */
+		if ((alloc_chrdev_region
+			(&sbus_dev, 0, MAX_DEVICES, "pensbus_dev")) < 0) {
+			pr_err("Cannot allocate major number\n");
+			return -1;
+		}
+		pr_debug("Major = %d Minor = %d \n", MAJOR(sbus_dev),
+			MINOR(sbus_dev));
+
+		/* Creating struct class */
+		dev_class = class_create("sbus_class");
+		if (dev_class == NULL) {
+			pr_err("Cannot create the struct class\n");
+			goto r_class;
+		}
+	}
+
+	major = MAJOR(sbus_dev);
+
+	/* Creating cdev structure */
+	cdev_init(&sbus_ring->cdev, &fops);
+	sbus_ring->cdev.owner = THIS_MODULE;
+	sbus_ring->cdev.ops = &fops;
+
+	/* Adding character device to the system */
+	device = MKDEV(major, dev_inst);
+	if ((cdev_add(&sbus_ring->cdev, device, 1)) < 0) {
+		pr_err("Cannot add the device to the system\n");
+		goto r_device;
+	}
+
+	/* Creating device */
+	if ((device_create(dev_class, NULL, device, NULL, "sbus%d",
+					sbus_ring_num)) == NULL) {
+		pr_err("Cannot create the Device 1\n");
+		goto r_device;
+	}
+	dev_inst++;
+
+	return 0;
+
+r_device:
+	if (dev_inst == 0)
+		class_destroy(dev_class);
+r_class:
+	if (dev_inst == 0)
+		unregister_chrdev_region(sbus_dev, MAX_DEVICES);
+
+	return -1;
+}
+
+/*
+ * Module exit function
+ */
+static int sbus_remove(struct platform_device *pdev)
+{
+	dev_inst--;
+
+	if (dev_inst == 0) {
+		device_destroy(dev_class, sbus_dev);
+		class_destroy(dev_class);
+		unregister_chrdev_region(sbus_dev, MAX_DEVICES);
+		pr_debug("Device Driver Remove...Done!!!\n");
+	}
+
+	return 0;
+}
+
+static const struct of_device_id sbus_of_match[] = {
+	{ .compatible = "pensando,sbus" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver sbus_driver = {
+	.probe = sbus_probe,
+	.remove = sbus_remove,
+	.driver = {
+		.name = "pensando-sbus",
+		.owner = THIS_MODULE,
+		.of_match_table = sbus_of_match,
+	},
+};
+
+module_platform_driver(sbus_driver);
-- 
2.25.1

