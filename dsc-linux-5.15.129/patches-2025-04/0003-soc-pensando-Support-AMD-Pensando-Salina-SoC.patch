From 4a7618257fe6b4ac1dcc53fc597189aec79d8634 Mon Sep 17 00:00:00 2001
From: Brad Larson <bradley.larson@amd.com>
Date: Sat, 5 Apr 2025 11:45:03 -0700
Subject: [PATCH 3/8] soc/pensando: Support AMD Pensando Salina SoC

Updates for Elba, Giglio and Salina SoC drivers.
Back ported from linux 6.8.12.

Signed-off-by: Brad Larson <bradley.larson@amd.com>
---
 drivers/soc/pensando/Kconfig           |  25 +++-
 drivers/soc/pensando/Makefile          |   1 +
 drivers/soc/pensando/cap_bsm.c         |  20 +--
 drivers/soc/pensando/cap_crash.c       | 124 ++---------------
 drivers/soc/pensando/cap_mem.c         | 179 ++++++++++++++++++++++++-
 drivers/soc/pensando/cap_pcie.c        |  23 +++-
 drivers/soc/pensando/cap_pcie_capri.h  |  44 ++++++
 drivers/soc/pensando/cap_pcie_common.h |  52 +++++++
 drivers/soc/pensando/cap_pcie_elba.h   |  47 +------
 drivers/soc/pensando/cap_pcie_giglio.h |  13 ++
 drivers/soc/pensando/cap_pcie_salina.h |  55 ++++++++
 drivers/soc/pensando/cap_reboot.c      |  10 +-
 drivers/soc/pensando/cap_rstcause.c    |   3 +-
 drivers/soc/pensando/cap_rstcause.h    |   2 +-
 drivers/soc/pensando/cap_soc.c         |   7 +
 drivers/soc/pensando/cap_tracepoint.h  | 175 ++++++++++++++++++++++++
 drivers/soc/pensando/cmn_pmu_irq.c     | 106 +++++++++++++++
 drivers/soc/pensando/kpcimgr.c         |  13 +-
 drivers/soc/pensando/kpcimgr_api.h     |   1 +
 drivers/soc/pensando/penfw.h           |  23 ++++
 drivers/soc/pensando/penfw_drv.c       |  16 ++-
 drivers/soc/pensando/penfw_smc.c       | 167 +++++++++++++++++++++--
 drivers/soc/pensando/penfw_sysfs.c     |  11 +-
 drivers/soc/pensando/penfw_sysfs.h     |   2 +-
 drivers/soc/pensando/sbus.c            |  22 +--
 25 files changed, 935 insertions(+), 206 deletions(-)
 create mode 100644 drivers/soc/pensando/cap_pcie_capri.h
 create mode 100644 drivers/soc/pensando/cap_pcie_common.h
 create mode 100644 drivers/soc/pensando/cap_pcie_giglio.h
 create mode 100644 drivers/soc/pensando/cap_pcie_salina.h
 create mode 100644 drivers/soc/pensando/cap_tracepoint.h
 create mode 100644 drivers/soc/pensando/cmn_pmu_irq.c

diff --git a/drivers/soc/pensando/Kconfig b/drivers/soc/pensando/Kconfig
index 4fced630b702..a56135d191c3 100644
--- a/drivers/soc/pensando/Kconfig
+++ b/drivers/soc/pensando/Kconfig
@@ -2,13 +2,29 @@ if ARCH_PENSANDO
 
 menu "Pensando SoC drivers"
 
+choice
+    prompt "SoC Select"
+    default ARCH_PENSANDO_ELBA_SOC
+
 config ARCH_PENSANDO_ELBA_SOC
 	bool "Elba SoC"
 	select DMA_OPS
-	default y
+	select REGMAP_SPI
 	help
 	  Support for the Pensando Elba SoC
 
+config ARCH_PENSANDO_GIGLIO_SOC
+	bool "Giglio SoC"
+	help
+	  Support for the Pensando Giglio SoC
+
+config ARCH_PENSANDO_SALINA_SOC
+	bool "Salina SoC"
+	select DMA_OPS
+	help
+	  Support for the Pensando Salina SoC
+endchoice
+
 config PENSANDO_SOC_CAPMEM
 	tristate "/dev/capmem driver for the Pensando SoCs"
 	depends on OF
@@ -16,6 +32,13 @@ config PENSANDO_SOC_CAPMEM
 	help
 	  Support for the Pensando SoC memory driver
 
+config PENSANDO_SOC_CAPMEM_HUGEPAGE
+	tristate "Enable hugepage support in capmem"
+	select TRANSPARENT_HUGEPAGE
+	default n
+	help
+	  Support for Huge pages in Pensando SoC memory driver
+
 config PENSANDO_SOC_PCIE
 	tristate "PCIe driver for Pensando SoCs"
 	depends on OF
diff --git a/drivers/soc/pensando/Makefile b/drivers/soc/pensando/Makefile
index 95689d347494..69e60319b1ba 100644
--- a/drivers/soc/pensando/Makefile
+++ b/drivers/soc/pensando/Makefile
@@ -14,3 +14,4 @@ obj-$(CONFIG_PENSANDO_SOC_CRASH) += cap_crash.o
 obj-$(CONFIG_PENSANDO_SOC_BSM) += cap_bsm.o
 obj-$(CONFIG_PENSANDO_SOC_PENFW) += penfw_smc.o penfw_sysfs.o penfw_drv.o
 obj-$(CONFIG_PENSANDO_SOC_SBUS) += sbus.o
+obj-$(CONFIG_ARCH_PENSANDO_SALINA_SOC) += cmn_pmu_irq.o
diff --git a/drivers/soc/pensando/cap_bsm.c b/drivers/soc/pensando/cap_bsm.c
index a55039fbf627..5a99cb7c4900 100644
--- a/drivers/soc/pensando/cap_bsm.c
+++ b/drivers/soc/pensando/cap_bsm.c
@@ -25,13 +25,13 @@ static struct bsm bsm;
 		int val = (bsm.val >> BSM_##s##_LSB) & BSM_##s##_MASK;	\
 		return sprintf(buf, "%d\n", val);			\
 	}								\
-	static DEVICE_ATTR_RO(n);
+	static DEVICE_ATTR_RO(n)
 
-BSM_SHOW_INT(wdt,      WDT)
-BSM_SHOW_INT(attempt,  ATTEMPT)
-BSM_SHOW_INT(stage,    STAGE)
-BSM_SHOW_INT(running,  RUNNING)
-BSM_SHOW_INT(autoboot, AUTOBOOT)
+BSM_SHOW_INT(wdt,      WDT);
+BSM_SHOW_INT(attempt,  ATTEMPT);
+BSM_SHOW_INT(stage,    STAGE);
+BSM_SHOW_INT(running,  RUNNING);
+BSM_SHOW_INT(autoboot, AUTOBOOT);
 
 static const char *fwnames[4] = {
 	"mainfwa", "mainfwb", "goldfw", "diagfw"
@@ -44,10 +44,10 @@ static const char *fwnames[4] = {
 		int val = (bsm.val >> BSM_##s##_LSB) & BSM_##s##_MASK;	\
 		return sprintf(buf, "%s\n", fwnames[val & 0x3]);	\
 	}								\
-	static DEVICE_ATTR_RO(n);
+	static DEVICE_ATTR_RO(n)
 
-BSM_SHOW_FWID(fwid,  FWID)
-BSM_SHOW_FWID(track, TRACK)
+BSM_SHOW_FWID(fwid,  FWID);
+BSM_SHOW_FWID(track, TRACK);
 
 static ssize_t success_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
@@ -110,7 +110,7 @@ static const struct of_device_id bsm_of_match[] = {
 
 static struct platform_driver bsm_driver = {
 	.driver = {
-		.name = "capri-bsm",
+		.name = "elba-bsm",
 		.of_match_table = bsm_of_match,
 		.suppress_bind_attrs = true,
 	},
diff --git a/drivers/soc/pensando/cap_crash.c b/drivers/soc/pensando/cap_crash.c
index c8d2852eaf95..555c35e56c78 100644
--- a/drivers/soc/pensando/cap_crash.c
+++ b/drivers/soc/pensando/cap_crash.c
@@ -8,10 +8,9 @@
 #include <linux/module.h>
 #include <linux/kmsg_dump.h>
 #include <linux/time.h>
-#include <linux/platform_device.h>
 #include <linux/panic_notifier.h>
+#include <linux/platform_device.h>
 #include <linux/of.h>
-#include <linux/of_address.h>
 #include "cap_reboot.h"
 
 #define PCRASH_NAME	"pensando-crash"
@@ -19,7 +18,6 @@
 struct pcrash_st {
 	struct platform_device	*pdev;
 	struct kmsg_dumper	dump;
-	void __iomem		*ctrlbase;
 	void __iomem		*flashbase;
 	resource_size_t		size;
 	void *panic_buf;
@@ -31,47 +29,7 @@ struct panicbuf_header {
 };
 
 static struct pcrash_st *pcrash;
-static u32 PANIC_SIGNATURE = 0x9d7a7318;
-
-/*
- * Prepare the Cadence Quad SPI Controller for
- * memory mapped crash dump writes.
- */
-
-#define CQSPI_REG_CONFIG                        0x00
-#define CQSPI_REG_CONFIG_ENB_DIR_ACC_CTRL       BIT(7)
-
-#define CQSPI_REG_WR_COMPLETION_CTRL            0x38
-#define CQSPI_REG_WR_DISABLE_AUTO_POLL          BIT(14)
-
-static void pcrash_prepare_controller(void)
-{
-	void __iomem *ctrl = pcrash->ctrlbase;
-	u32 val;
-
-	/*
-	 * Re-enable the Direct Access Controller (memory-mapped access).
-	 */
-	val = readl(ctrl + CQSPI_REG_CONFIG);
-	if (!(val & CQSPI_REG_CONFIG_ENB_DIR_ACC_CTRL)) {
-		val |= CQSPI_REG_CONFIG_ENB_DIR_ACC_CTRL;
-		writel(val, ctrl + CQSPI_REG_CONFIG);
-	}
-
-	/*
-	 * Re-enable auto-polling, if it was disabled.
-	 * This is required for memory-mapped writes.
-	 */
-	val = readl(ctrl + CQSPI_REG_WR_COMPLETION_CTRL);
-	if (val & CQSPI_REG_WR_DISABLE_AUTO_POLL) {
-		val &= ~CQSPI_REG_WR_DISABLE_AUTO_POLL;
-		writel(val, ctrl + CQSPI_REG_WR_COMPLETION_CTRL);
-	}
-
-	/* readback + barrier */
-	(void)readl(ctrl + CQSPI_REG_CONFIG);
-	__iowmb();
-}
+static u32 PANIC_SIGNATURE = 0x9D7A7318;
 
 static void pcrash_do_dump(struct kmsg_dumper *dumper,
 			   enum kmsg_dump_reason reason)
@@ -83,11 +41,6 @@ static void pcrash_do_dump(struct kmsg_dumper *dumper,
 	u32 __iomem *dst = (u32 *)pcrash->flashbase;
 	struct panicbuf_header *hdr = pcrash->flashbase;
 
-	/*
-	 * Prepare the flash controller for memory-mapped writes.
-	 */
-	pcrash_prepare_controller();
-
 	/*
 	 * read first 32bits, if all ff then the new panic data
 	 * can be written to the panic buf.
@@ -127,35 +80,11 @@ static struct notifier_block cap_panic_notifier = {
 	.notifier_call = cap_panic_callback,
 };
 
-static int pcrash_get_flash_controller(struct platform_device *pdev,
-	struct resource *res)
-{
-	const struct device_node *np;
-	struct device_node *dn;
-	int err = -ENODEV;
-
-	np = pdev->dev.of_node;
-	if (np) {
-		/*
-		 * The pensando,crash-ctrl property should be a phandle
-		 * to a pensando,elba-qspi controller.
-		 * Extract its register space, if found.
-		 */
-		dn = of_parse_phandle(np, "pensando,crash-ctrl", 0);
-		if (of_device_is_compatible(dn, "pensando,elba-qspi"))
-			if (!of_address_to_resource(dn, 0, res))
-				err = 0;
-		of_node_put(dn);
-	}
-	return err;
-}
-
 static int pcrash_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
-	struct resource ctrlres;
 	struct resource *res;
-	int err = -ENODEV;
+	int err;
 
 	pcrash = devm_kzalloc(dev, sizeof(*pcrash), GFP_KERNEL);
 	if (!pcrash)
@@ -164,56 +93,32 @@ static int pcrash_probe(struct platform_device *pdev)
 	pcrash->pdev = pdev;
 	platform_set_drvdata(pdev, pcrash);
 
-	/* get and map the flash controller */
-	if (pcrash_get_flash_controller(pdev, &ctrlres)) {
-		dev_err(dev, "%s: Cannot find flash controller.\n", pdev->name);
-		return -ENODEV;
-	}
-	pcrash->ctrlbase = ioremap(ctrlres.start, resource_size(&ctrlres));
-	if (!pcrash->ctrlbase) {
-		dev_err(dev, "%s: Cannot map flash controller.\n", pdev->name);
-		return -ENODEV;
-	}
+	pcrash->dump.max_reason = KMSG_DUMP_PANIC;
+	pcrash->dump.dump = pcrash_do_dump;
 
-	/* get and map the memory-mapped flash */
+	/* Obtain and remap flash address. */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(dev, "%s: Memory resource not found\n", pdev->name);
-		goto bail1;
-	}
 	pcrash->flashbase = devm_ioremap_resource(dev, res);
 	if (IS_ERR(pcrash->flashbase)) {
-		dev_err(dev, "%s: Cannot remap flash address.\n", pdev->name);
-		err = PTR_ERR(pcrash->flashbase);
-		goto bail1;
+		dev_err(dev, "Cannot remap flash address.\n");
+		return PTR_ERR(pcrash->flashbase);
 	}
 	pcrash->size = resource_size(res);
 	pcrash->panic_buf = vmalloc(pcrash->size);
 	if (!pcrash->panic_buf) {
-		dev_err(dev, "%s: Failed to allocate buffer workspace\n",
-				pdev->name);
-		err = -ENOMEM;
-		goto bail1;
+		dev_err(dev, "failed to allocate buffer workspace\n");
+		return -ENOMEM;
 	}
 	memset(pcrash->panic_buf, 0xff, pcrash->size);
 	atomic_notifier_chain_register(&panic_notifier_list,
 				       &cap_panic_notifier);
-	pcrash->dump.max_reason = KMSG_DUMP_PANIC;
-	pcrash->dump.dump = pcrash_do_dump;
 	err = kmsg_dump_register(&pcrash->dump);
 	if (err) {
-		dev_err(dev, "%s: registering kmsg dumper failed, error %d\n",
-				pdev->name, err);
-		goto bail2;
+		vfree(pcrash->panic_buf);
+		dev_err(dev, "%s: registering kmsg dumper failed, error %d\n", __func__, err);
+		return err;
 	}
 	return 0;
-bail2:
-	atomic_notifier_chain_unregister(&panic_notifier_list,
-					 &cap_panic_notifier);
-	vfree(pcrash->panic_buf);
-bail1:
-	iounmap(pcrash->ctrlbase);
-	return err;
 }
 
 static int pcrash_remove(struct platform_device *pdev)
@@ -225,7 +130,6 @@ static int pcrash_remove(struct platform_device *pdev)
 	atomic_notifier_chain_unregister(&panic_notifier_list,
 					 &cap_panic_notifier);
 	vfree(pcrash->panic_buf);
-	iounmap(pcrash->ctrlbase);
 	return 0;
 }
 
@@ -248,6 +152,6 @@ static struct platform_driver pcrash_platform_driver = {
 module_platform_driver(pcrash_platform_driver);
 
 MODULE_DESCRIPTION("Pensando Panic Crash Driver");
-MODULE_LICENSE("GPL v2");
+MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:" PCRASH_NAME);
 MODULE_AUTHOR("Rahul Shekhar <rahulshekhar@pensando.io>");
diff --git a/drivers/soc/pensando/cap_mem.c b/drivers/soc/pensando/cap_mem.c
index b39ef6953f0e..25138aedeec2 100644
--- a/drivers/soc/pensando/cap_mem.c
+++ b/drivers/soc/pensando/cap_mem.c
@@ -19,6 +19,11 @@
 #include <dt-bindings/soc/pensando,capmem.h>
 #include "capmem_dev.h"
 
+#define CREATE_TRACE_POINTS
+#include "cap_tracepoint.h"
+
+#define CAPMEM_REGION_ALIGN		PMD_SIZE
+
 /*
  * Memory range information provided by U-Boot on the kernel commandline:
  * Syntax:
@@ -59,6 +64,169 @@ static int capmem_add_range(uint64_t start, uint64_t len, int type)
 	return 0;
 }
 
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+static vm_fault_t cap_mem_pte_fault(struct vm_fault *vmf)
+{
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	vm_fault_t rc;
+
+	trace_cap_mem_pte_fault(vma, vmf);
+
+	pgoff = vmf->pgoff;
+	phys = PFN_PHYS(pgoff);
+
+	trace_cap_mem_vmf_insert_pfn_pte(vma, vmf, phys);
+
+	rc = vmf_insert_pfn(vma, vmf->address, PFN_DOWN(phys));
+	if (rc == -ENOMEM)
+		return VM_FAULT_OOM;
+	if (rc < 0 && rc != -EBUSY)
+		return VM_FAULT_SIGBUS;
+
+	return VM_FAULT_NOPAGE;
+}
+
+static vm_fault_t cap_mem_pmd_fault(struct vm_fault *vmf)
+{
+	unsigned long pmd_addr = vmf->address & PMD_MASK;
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	pfn_t pfn;
+
+	trace_cap_mem_pmd_fault(vma, vmf);
+
+	if (pmd_addr < vma->vm_start || (pmd_addr + PMD_SIZE) > vma->vm_end)
+		return VM_FAULT_FALLBACK;
+
+	pgoff = linear_page_index(vma, pmd_addr);
+	phys = PFN_PHYS(pgoff);
+
+	if (!IS_ALIGNED(phys, PMD_SIZE))
+		return VM_FAULT_FALLBACK;
+
+	trace_cap_mem_vmf_insert_pfn_pmd(vma, vmf, phys);
+
+	pfn = phys_to_pfn_t(phys, PFN_DEV|PFN_MAP);
+
+	return vmf_insert_pfn_pmd(vmf, pfn, vmf->flags & FAULT_FLAG_WRITE);
+}
+
+#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
+static vm_fault_t cap_mem_pud_fault(struct vm_fault *vmf)
+{
+	unsigned long pud_addr = vmf->address & PUD_MASK;
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	pfn_t pfn;
+
+	trace_cap_mem_pud_fault(vma, vmf);
+
+	if (pud_addr < vma->vm_start || (pud_addr + PUD_SIZE) > vma->vm_end)
+		return VM_FAULT_FALLBACK;
+
+	pgoff = linear_page_index(vma, pud_addr);
+	phys = PFN_PHYS(pgoff);
+
+	if (!IS_ALIGNED(phys, PUD_SIZE))
+		return VM_FAULT_FALLBACK;
+
+	trace_cap_mem_vmf_insert_pfn_pud(vma, vmf, phys);
+
+	pfn = phys_to_pfn_t(phys, PFN_DEV|PFN_MAP);
+
+	return vmf_insert_pfn_pud(vmf, pfn, vmf->flags & FAULT_FLAG_WRITE);
+}
+#else
+static vm_fault_t cap_mem_pud_fault(struct vm_fault *vmf)
+{
+	return VM_FAULT_FALLBACK;
+}
+#endif /* !CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD */
+
+static vm_fault_t cap_mem_huge_fault(struct vm_fault *vmf,
+		enum page_entry_size pe_size)
+{
+	vm_fault_t rc;
+
+	trace_cap_mem_fault_enter(vmf->vma, vmf);
+
+	switch (pe_size) {
+	case PE_SIZE_PTE:
+		rc = cap_mem_pte_fault(vmf);
+		break;
+	case PE_SIZE_PMD:
+		rc = cap_mem_pmd_fault(vmf);
+		break;
+	case PE_SIZE_PUD:
+		rc = cap_mem_pud_fault(vmf);
+		break;
+	default:
+		rc = VM_FAULT_SIGBUS;
+	}
+
+	trace_cap_mem_fault_exit(vmf->vma, vmf);
+
+	return rc;
+}
+
+static vm_fault_t cap_mem_fault(struct vm_fault *vmf)
+{
+	return cap_mem_huge_fault(vmf, PE_SIZE_PTE);
+}
+
+static int cap_mem_may_split(struct vm_area_struct *vma, unsigned long addr)
+{
+	return -EINVAL;
+}
+
+static const struct vm_operations_struct cap_mem_vm_ops = {
+	.fault = cap_mem_fault,
+	.huge_fault = cap_mem_huge_fault,
+	.may_split = cap_mem_may_split,
+};
+
+static unsigned long cap_mem_get_unmapped_area(struct file *filp,
+		unsigned long addr, unsigned long len, unsigned long pgoff,
+		unsigned long flags)
+{
+	unsigned long off, len_align, addr_align, align;
+
+	align = PAGE_SIZE;
+	off = pgoff << PAGE_SHIFT;
+
+	if (len >= PMD_SIZE && IS_ALIGNED(off, PMD_SIZE))
+		align = PMD_SIZE;
+
+#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
+	if (len >= PUD_SIZE && IS_ALIGNED(off, PUD_SIZE))
+		align = PUD_SIZE;
+#endif
+
+	trace_cap_mem_get_unmapped_area_enter(addr, len, pgoff, align);
+
+	if (align == PAGE_SIZE)
+		goto out;
+
+	len_align = len + align;
+
+	addr = current->mm->get_unmapped_area(filp, addr, len_align, pgoff, flags);
+	if (!IS_ERR_VALUE(addr)) {
+		addr_align = round_up(addr, align);
+		trace_cap_mem_get_unmapped_area_exit(addr_align, len_align, pgoff, align);
+		return addr_align;
+	}
+
+out:
+	addr = current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);
+	trace_cap_mem_get_unmapped_area_exit(addr, len, pgoff, align);
+	return addr;
+}
+#endif
+
 static int cap_mem_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	size_t size = vma->vm_end - vma->vm_start;
@@ -116,6 +284,10 @@ static int cap_mem_mmap(struct file *file, struct vm_area_struct *vma)
 
 	vma->vm_page_prot = pgprot;
 
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+	vma->vm_ops = &cap_mem_vm_ops;
+	vma->vm_flags |= VM_PFNMAP | VM_HUGEPAGE | VM_DONTEXPAND | VM_DONTDUMP;
+#else
 	/* Remap-pfn-range will mark the range VM_IO */
 	if (remap_pfn_range(vma,
 			    vma->vm_start,
@@ -124,6 +296,7 @@ static int cap_mem_mmap(struct file *file, struct vm_area_struct *vma)
 			    vma->vm_page_prot)) {
 		return -EAGAIN;
 	}
+#endif
 
 	return 0;
 }
@@ -177,6 +350,9 @@ const struct file_operations cap_mem_fops = {
 	.owner		= THIS_MODULE,
 	.mmap		= cap_mem_mmap,
 	.unlocked_ioctl	= cap_mem_unlocked_ioctl,
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+	.get_unmapped_area = cap_mem_get_unmapped_area,
+#endif
 };
 
 static struct miscdevice cap_mem_dev = {
@@ -239,9 +415,10 @@ static int load_of_ranges(struct platform_device *pdev, const char *pname)
 
 	n = of_property_read_variable_u32_array(pdev->dev.of_node,
 			pname, (u32 *)entries, 0,
-			sizeof (entries) / sizeof (u32));
+			sizeof(entries) / sizeof(u32));
 	if (n < 0)
 		return -ENOENT;
+
 	if (n % 5 != 0) {
 		dev_err(&pdev->dev, "of %s invalid\n", pname);
 		return -ENODEV;
diff --git a/drivers/soc/pensando/cap_pcie.c b/drivers/soc/pensando/cap_pcie.c
index 3c43f56d3a9e..1bfc15bb7bc8 100644
--- a/drivers/soc/pensando/cap_pcie.c
+++ b/drivers/soc/pensando/cap_pcie.c
@@ -21,7 +21,18 @@
 #include "cap_reboot.h"
 #include "cap_rstcause.h"
 #include "penpcie_dev.h"
+#ifdef CONFIG_ARCH_PENSANDO_CAPRI_SOC
+#include "cap_pcie_capri.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_ELBA_SOC
 #include "cap_pcie_elba.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_GIGLIO_SOC
+#include "cap_pcie_giglio.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_SALINA_SOC
+#include "cap_pcie_salina.h"
+#endif
 
 #define DRV_NAME	"cap_pcie"
 #define PFX		DRV_NAME ": "
@@ -41,6 +52,7 @@ struct pciedev_info {
 	int pciep_access_error;
 	spinlock_t pciep_access_lock;
 	long (*saved_panic_blink)(int state);
+	u32 hotplug_delaylnkup;
 };
 
 static struct pciedev_info pciedev_info;
@@ -79,7 +91,10 @@ int platform_serror(struct pt_regs *regs, unsigned int esr)
 	if (pciep_access_in_progress())
 		return 1;
 
-	if ((esr >> 26) == 0x2f && (esr & 0x3) == 0x0) { /* Decode Error */
+	// TODO: Salina N1 async SError user mode convert to bus error
+	// ESR_ELx[5:0] = 0b010001  Asynchronous SError exception
+	if (((esr & 0x11) == 0x11) ||
+	    ((esr >> 26) == 0x2f && (esr & 0x3) == 0x0)) { /* Decode Error */
 		if (user_mode(regs)) {
 			struct task_struct *tsk = current;
 
@@ -302,6 +317,8 @@ static void cap_reset(void)
  *
  * If we haven't yet initialized the link (ltssm_en=0) then the
  * host side hasn't come up yet.  In that case just reset immediately.
+ *
+ * If hotplug enabled then reset immediately
  */
 static long pcie_panic_blink(int state)
 {
@@ -312,7 +329,7 @@ static long pcie_panic_blink(int state)
 		cap_reset();
 
 	port = pcie_get_ltssm_en();
-	if (port >= 0) {
+	if (!pciedev_info.hotplug_delaylnkup && port >= 0) {
 		pr_info(PFX "port %d enabled\n", port);
 		pcie_set_crs(0);
 		while ((port = pcie_poll_for_hostdn()) < 0)
@@ -389,6 +406,8 @@ static int pcie_probe(struct platform_device *pd)
 	pi->pcie_base = res.start;
 	pi->pcie_size = resource_size(&res);
 
+	of_property_read_u32(dn, "hotplug_delaylnkup", &pi->hotplug_delaylnkup);
+
 	err = misc_register(&pcie_dev);
 	if (err) {
 		pr_err(PFX "register pcie_dev failed: %d\n", err);
diff --git a/drivers/soc/pensando/cap_pcie_capri.h b/drivers/soc/pensando/cap_pcie_capri.h
new file mode 100644
index 000000000000..ffd39d083e5c
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_capri.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_CAPRI_H__
+#define __CAP_PCIE_CAPRI_H__
+
+#define PCIEPORT_NPORTS		8
+
+#define CAP_ADDR_BASE_PP_PP_OFFSET 0x7000000
+#define CAP_PXC_CSR_BYTE_SIZE 0x00002000
+
+#define CAP_PP_CSR_PORT_C_CFG_C_PORT_MAC_BYTE_ADDRESS 0x110f8
+#define CAP_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
+#define CAP_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
+
+#define CAP_PP_CSR_PORT_C_INT_C_MAC_INTREG_BYTE_ADDRESS 0x111b0
+#define CAP_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
+
+#define _PP_BASE(pn)    CAP_ADDR_BASE_PP_PP_OFFSET
+#define PP_(REG, pn)	(_PP_BASE(pn) + CAP_PP_CSR_ ##REG## _BYTE_ADDRESS)
+#define _PXC_OFFSET(pn)	((pn) * CAP_PXC_CSR_BYTE_SIZE)
+#define _PXC_REG_(REG)	(CAP_PP_CSR_PORT_C_ ##REG## _BYTE_ADDRESS)
+#define PXC_(REG, pn)	(_PP_BASE(pn) + _PXC_OFFSET(pn) + _PXC_REG_(REG))
+
+#define CFG_MACF_(REG) \
+	(CAP_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
+#define MAC_INTREGF_(REG) \
+	(CAP_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
+
+#define CAP_MS_CSR_CFG_WDT_RST_EN_LSB 0
+#define CFG_WDT_RST_EN  CAP_MS_CSR_CFG_WDT_RST_EN_LSB
+
+#define WDT_CR          0x00
+#define WDT_TORR        0x01
+#define WDT_CRR         0x03
+
+#define WDT_CR_ENABLE   0x1
+#define WDT_CR_PCLK_256 (0x7 << 2)
+
+#define WDT_KICK_VAL    0x76
+
+#endif /* __CAP_PCIE_CAPRI_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_common.h b/drivers/soc/pensando/cap_pcie_common.h
new file mode 100644
index 000000000000..e54a0fdcf97e
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_common.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_COMMON_H__
+#define __CAP_PCIE_COMMON_H__
+
+#define ELB_ADDR_BASE_PP_PXC_0_OFFSET 0x20100000
+#define ELB_ADDR_BASE_PP_PXC_0_SIZE 0x40000
+#define ELB_ADDR_BASE_PP_PP_0_OFFSET 0x20300000
+#define ELB_ADDR_BASE_PP_PP_0_SIZE 0x40000
+
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_BYTE_ADDRESS 0x20f8
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
+
+#define ELB_PXC_CSR_INT_C_MAC_INTREG_BYTE_ADDRESS 0x2220
+#define ELB_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
+
+#define _PP_BASE(pn) \
+	(ELB_ADDR_BASE_PP_PP_0_OFFSET + \
+	(((pn) >> 2) * ELB_ADDR_BASE_PP_PP_0_SIZE))
+
+#define PP_(REG, pn) \
+	(_PP_BASE(pn) + ELB_PP_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define _PXC_BASE(pn) \
+	(ELB_ADDR_BASE_PP_PXC_0_OFFSET + \
+	((pn) * ELB_ADDR_BASE_PP_PXC_0_SIZE))
+
+#define PXC_(REG, pn) \
+	(_PXC_BASE(pn) + ELB_PXC_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define CFG_MACF_(REG) \
+	(ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
+#define MAC_INTREGF_(REG) \
+	(ELB_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
+
+#define ELB_SOC_CSR_CFG_WDT_RST_EN_LSB 0
+#define CFG_WDT_RST_EN  ELB_SOC_CSR_CFG_WDT_RST_EN_LSB
+
+#define WDT_CR          0x00
+#define WDT_TORR        0x01
+#define WDT_CRR         0x03
+
+#define WDT_CR_ENABLE   0x1
+#define WDT_CR_PCLK_256 (0x7 << 2)
+
+#define WDT_KICK_VAL    0x76
+
+#endif /* __CAP_PCIE_COMMON_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_elba.h b/drivers/soc/pensando/cap_pcie_elba.h
index b79046ae9db6..e23ca250df93 100644
--- a/drivers/soc/pensando/cap_pcie_elba.h
+++ b/drivers/soc/pensando/cap_pcie_elba.h
@@ -1,54 +1,13 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /*
- * Copyright (c) 2021, Pensando Systems Inc.
+ * Copyright (c) 2021-2022, Pensando Systems Inc.
  */
 
 #ifndef __CAP_PCIE_ELBA_H__
 #define __CAP_PCIE_ELBA_H__
 
-#define PCIEPORT_NPORTS		8
-
-#define ELB_ADDR_BASE_PP_PXC_0_OFFSET 0x20100000
-#define ELB_ADDR_BASE_PP_PXC_0_SIZE 0x40000
-#define ELB_ADDR_BASE_PP_PP_0_OFFSET 0x20300000
-#define ELB_ADDR_BASE_PP_PP_0_SIZE 0x40000
-
-#define ELB_PXC_CSR_CFG_C_PORT_MAC_BYTE_ADDRESS 0x20f8
-#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
-#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
-
-#define ELB_PXC_CSR_INT_C_MAC_INTREG_BYTE_ADDRESS 0x2220
-#define ELB_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
-
-#define _PP_BASE(pn) \
-	(ELB_ADDR_BASE_PP_PP_0_OFFSET + \
-	(((pn) >> 2) * ELB_ADDR_BASE_PP_PP_0_SIZE))
-
-#define PP_(REG, pn) \
-	(_PP_BASE(pn) + ELB_PP_CSR_ ##REG## _BYTE_ADDRESS)
-
-#define _PXC_BASE(pn) \
-	(ELB_ADDR_BASE_PP_PXC_0_OFFSET + \
-	((pn) * ELB_ADDR_BASE_PP_PXC_0_SIZE))
+#include "cap_pcie_common.h"
 
-#define PXC_(REG, pn) \
-	(_PXC_BASE(pn) + ELB_PXC_CSR_ ##REG## _BYTE_ADDRESS)
-
-#define CFG_MACF_(REG) \
-	(ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
-#define MAC_INTREGF_(REG) \
-	(ELB_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
-
-#define ELB_SOC_CSR_CFG_WDT_RST_EN_LSB 0
-#define CFG_WDT_RST_EN  ELB_SOC_CSR_CFG_WDT_RST_EN_LSB
-
-#define WDT_CR          0x00
-#define WDT_TORR        0x01
-#define WDT_CRR         0x03
-
-#define WDT_CR_ENABLE   0x1
-#define WDT_CR_PCLK_256 (0x7 << 2)
-
-#define WDT_KICK_VAL    0x76
+#define PCIEPORT_NPORTS		8
 
 #endif /* __CAP_PCIE_ELBA_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_giglio.h b/drivers/soc/pensando/cap_pcie_giglio.h
new file mode 100644
index 000000000000..ffe21a635ffc
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_giglio.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_GIGLIO_H__
+#define __CAP_PCIE_GIGLIO_H__
+
+#include "cap_pcie_common.h"
+
+#define PCIEPORT_NPORTS		4
+
+#endif /* __CAP_PCIE_GIGLIO_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_salina.h b/drivers/soc/pensando/cap_pcie_salina.h
new file mode 100644
index 000000000000..d1ff28bc9b5e
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_salina.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_SALA_H__
+#define __CAP_PCIE_SALA_H__
+
+#define PCIEPORT_NPORTS		8
+
+#define SAL_ADDR_BASE_PP_PXC_0_OFFSET 0x20100000
+#define SAL_ADDR_BASE_PP_PXC_0_SIZE 0x40000
+#define SAL_ADDR_BASE_PP_PP_0_OFFSET 0x20300000
+#define SAL_ADDR_BASE_PP_PP_0_SIZE 0x40000
+
+//Verify this offsets in Salina
+#define SAL_PXC_CSR_CFG_C_PORT_MAC_BYTE_ADDRESS 0x20f8
+#define SAL_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
+#define SAL_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
+
+#define SAL_PXC_CSR_INT_C_MAC_INTREG_BYTE_ADDRESS 0x2220
+#define SAL_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
+
+#define _PP_BASE(pn) \
+	(SAL_ADDR_BASE_PP_PP_0_OFFSET + \
+	(((pn) >> 2) * SAL_ADDR_BASE_PP_PP_0_SIZE))
+
+#define PP_(REG, pn) \
+	(_PP_BASE(pn) + SAL_PP_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define _PXC_BASE(pn) \
+	(SAL_ADDR_BASE_PP_PXC_0_OFFSET + \
+	((pn) * SAL_ADDR_BASE_PP_PXC_0_SIZE))
+
+#define PXC_(REG, pn) \
+	(_PXC_BASE(pn) + SAL_PXC_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define CFG_MACF_(REG) \
+	(SAL_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
+#define MAC_INTREGF_(REG) \
+	(SAL_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
+
+#define SAL_SOC_CSR_CFG_WDT_RST_EN_LSB 0
+#define CFG_WDT_RST_EN  SAL_SOC_CSR_CFG_WDT_RST_EN_LSB
+
+#define WDT_CR          0x00
+#define WDT_TORR        0x01
+#define WDT_CRR         0x03
+
+#define WDT_CR_ENABLE   0x1
+#define WDT_CR_PCLK_256 (0x7 << 2)
+
+#define WDT_KICK_VAL    0x76
+
+#endif /* __CAP_PCIE_SALA_H__ */
diff --git a/drivers/soc/pensando/cap_reboot.c b/drivers/soc/pensando/cap_reboot.c
index d2e1ebf91292..ddf2794fe80b 100644
--- a/drivers/soc/pensando/cap_reboot.c
+++ b/drivers/soc/pensando/cap_reboot.c
@@ -5,6 +5,7 @@
  * Copyright (c) 2020-2022, Pensando Systems Inc.
  */
 
+#include <linux/kobject.h>
 #include <linux/string.h>
 #include <linux/sysfs.h>
 #include <linux/module.h>
@@ -27,15 +28,12 @@ bool cap_panic_reboot(void)
 		return true;
 	return false;
 }
-EXPORT_SYMBOL_GPL(cap_panic_reboot);
 
 unsigned long cap_boot_count(void)
 {
 	return boot_count;
 }
-EXPORT_SYMBOL_GPL(cap_boot_count);
 
-extern struct kobject *pensando_fw_kobj_get(void);
 struct kobject *reboot_kobj;
 
 static ssize_t panic_reboot_show(struct kobject *kobj,
@@ -91,13 +89,9 @@ static struct attribute_group attr_group = {
 
 static int __init capri_reboot_init(void)
 {
-	struct kobject *pensando_kobj;
 	int ret;
 
-	pensando_kobj = pensando_fw_kobj_get();
-	if (!pensando_kobj)
-		return -ENOMEM;
-	reboot_kobj = kobject_create_and_add("reboot", pensando_kobj);
+	reboot_kobj = kobject_create_and_add("reboot_pensando", kernel_kobj);
 	if (!reboot_kobj)
 		return -ENOMEM;
 
diff --git a/drivers/soc/pensando/cap_rstcause.c b/drivers/soc/pensando/cap_rstcause.c
index 9ef13609d7a4..3fdc7e456eaa 100644
--- a/drivers/soc/pensando/cap_rstcause.c
+++ b/drivers/soc/pensando/cap_rstcause.c
@@ -11,8 +11,8 @@
 #include <linux/sysfs.h>
 #include <linux/export.h>
 #include <linux/module.h>
-#include <linux/platform_device.h>
 #include <linux/panic_notifier.h>
+#include <linux/platform_device.h>
 #include <linux/of.h>
 #include <linux/init.h>
 #include <linux/reboot.h>
@@ -60,7 +60,6 @@ void cap_rstcause_set(u32 mask)
 	if (g_rdev)
 		set_next_cause_reg(g_rdev, mask);
 }
-
 EXPORT_SYMBOL_GPL(cap_rstcause_set);
 
 static int rstcause_reboot_handler(struct notifier_block *this,
diff --git a/drivers/soc/pensando/cap_rstcause.h b/drivers/soc/pensando/cap_rstcause.h
index 12fe87164792..7807770a4d75 100644
--- a/drivers/soc/pensando/cap_rstcause.h
+++ b/drivers/soc/pensando/cap_rstcause.h
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: GPL-2.0
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (c) 2021, Pensando Systems Inc.
  */
diff --git a/drivers/soc/pensando/cap_soc.c b/drivers/soc/pensando/cap_soc.c
index 9942c203405b..b92c064970e3 100644
--- a/drivers/soc/pensando/cap_soc.c
+++ b/drivers/soc/pensando/cap_soc.c
@@ -3,10 +3,17 @@
  * Copyright (c) 2021, Pensando Systems Inc.
  */
 
+#include <linux/spinlock.h>
 #include <linux/export.h>
 #include <linux/kobject.h>
 
+#ifdef CONFIG_ARCH_PENSANDO_CAPRI_SOC
+DEFINE_SPINLOCK(apb_bus_spinlock);
+EXPORT_SYMBOL_GPL(apb_bus_spinlock);
+#endif
+
 static struct kobject *pensando_fw_kobj;
+struct kobject *pensando_fw_kobj_get(void);
 
 /*
  * Creates a new pensando sysfs node if it does not exists. The kobj is
diff --git a/drivers/soc/pensando/cap_tracepoint.h b/drivers/soc/pensando/cap_tracepoint.h
new file mode 100644
index 000000000000..17510958d648
--- /dev/null
+++ b/drivers/soc/pensando/cap_tracepoint.h
@@ -0,0 +1,175 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM pensando
+
+#if !defined(_CAP_TRACEPOINT_H_) || defined(TRACE_HEADER_MULTI_READ)
+#define _CAP_TRACEPOINT_H_
+
+#include <linux/tracepoint.h>
+#include <linux/mm_types.h>
+
+DECLARE_EVENT_CLASS(cap_mem_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, vm_start)
+		__field(unsigned long, vm_end)
+		__field(unsigned long, va)
+		__field(unsigned long, pa)
+	),
+
+	TP_fast_assign(
+		__entry->vm_start = vma->vm_start;
+		__entry->vm_end = vma->vm_end;
+		__entry->va = vmf->address;
+		__entry->pa = vmf->pgoff << PAGE_SHIFT;
+	),
+
+	TP_printk("vm_start 0x%lx vm_end 0x%lx va 0x%lx pa 0x%lx",
+		__entry->vm_start,
+		__entry->vm_end,
+		__entry->va,
+		__entry->pa
+	)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_fault_enter,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_fault_exit,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pte_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pmd_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pud_fault,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+	TP_ARGS(vma, vmf)
+);
+
+DECLARE_EVENT_CLASS(cap_mem_get_unmapped_area,
+
+TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+	TP_ARGS(va, len, pgoff, align),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, va)
+		__field(unsigned long, len)
+		__field(unsigned long, pa)
+		__field(unsigned long, align)
+	),
+
+	TP_fast_assign(
+		__entry->va = va;
+		__entry->len = len;
+		__entry->pa = pgoff << PAGE_SHIFT;
+		__entry->align = align;
+	),
+
+	TP_printk("vm_start 0x%lx vm_end 0x%lx pa 0x%lx align 0x%lx",
+		__entry->va,
+		__entry->va + __entry->len,
+		__entry->pa,
+		__entry->align
+	)
+);
+
+DEFINE_EVENT(cap_mem_get_unmapped_area, cap_mem_get_unmapped_area_enter,
+
+	TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+	TP_ARGS(va, len, pgoff, align)
+);
+
+DEFINE_EVENT(cap_mem_get_unmapped_area, cap_mem_get_unmapped_area_exit,
+
+	TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+	TP_ARGS(va, len, pgoff, align)
+);
+
+DECLARE_EVENT_CLASS(cap_mem_vmf_insert_pfn,
+
+TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa),
+
+	TP_STRUCT__entry(
+		__field(unsigned long, vm_start)
+		__field(unsigned long, vm_end)
+		__field(unsigned long, va)
+		__field(unsigned long, pa)
+	),
+
+	TP_fast_assign(
+		__entry->vm_start = vma->vm_start;
+		__entry->vm_end = vma->vm_end;
+		__entry->va = vmf->address;
+		__entry->pa = pa;
+	),
+
+	TP_printk("vm_start 0x%lx vm_end 0x%lx va 0x%lx pa 0x%lx",
+		__entry->vm_start,
+		__entry->vm_end,
+		__entry->va,
+		__entry->pa
+	)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pte,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pmd,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pud,
+
+	TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+	TP_ARGS(vma, vmf, pa)
+);
+
+#endif  /* !defined(_CAP_TRACEPOINT_H_) || defined(TRACE_HEADER_MULTI_READ) */
+
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE cap_tracepoint
+#include <trace/define_trace.h>
diff --git a/drivers/soc/pensando/cmn_pmu_irq.c b/drivers/soc/pensando/cmn_pmu_irq.c
new file mode 100644
index 000000000000..2299611dc319
--- /dev/null
+++ b/drivers/soc/pensando/cmn_pmu_irq.c
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * AMD Pensando Salina SoC CMN PMU Interrupt Handler
+ *
+ * Copyright 2024 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+
+/*
+ * The cmn_pmu_int reg base/size region is a small mapping that includes the
+ * Salina CMN PMU CSR interrupt and AXI interrupt registers to initialize and
+ * service the CMN PMU interrupt.  Below are offsets to iomem base.
+ */
+#define SAL_CMN_PMU_CSR_CSR_INT         0x00
+#define SAL_CMN_PMU_CSR_NXCW_INTREG     0x20
+#define SAL_CMN_PMU_CSR_NXCW_INT_TEST   0x24
+#define SAL_CMN_PMU_CSR_NXCW_INT_ENABLE 0x28
+#define SAL_CMN_PMU_CSR_NXCW_INT_CLEAR  0x2c
+
+static irqreturn_t cmn_pmu_irq_handler(int irq, void *regs)
+{
+	writel(BIT(0), regs + SAL_CMN_PMU_CSR_NXCW_INTREG);
+	return IRQ_HANDLED;
+}
+
+static int salina_cmn_pmu_irq_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct resource res;
+	void __iomem *regs;
+	size_t res_size;
+	int irq, ret;
+
+	ret = of_address_to_resource(node, 0, &res);
+	if (ret) {
+		pr_err("Failed to get memory resource\n");
+		return ret;
+	}
+	res_size = resource_size(&res);
+
+	if (!request_mem_region(res.start, res_size, "cmn_pmu_int")) {
+		pr_err("Failed to request memory region\n");
+		return -EBUSY;
+	}
+
+	regs = ioremap(res.start, res_size);
+	if (!regs) {
+		pr_err("Failed to remap memory region\n");
+		ret = -ENOMEM;
+		goto release_resource;
+	}
+
+	writel(GENMASK(13, 0), regs + SAL_CMN_PMU_CSR_NXCW_INT_CLEAR); /* Disable interrupts */
+	writel(GENMASK(13, 0), regs + SAL_CMN_PMU_CSR_NXCW_INTREG);    /* Ack interrupts */
+	writel(BIT(1), regs + SAL_CMN_PMU_CSR_CSR_INT);                /* Enable downstream int */
+	writel(BIT(0), regs + SAL_CMN_PMU_CSR_NXCW_INT_ENABLE);        /* Enable eMMC int */
+
+	irq = irq_of_parse_and_map(node, 0);
+	if (irq <= 0) {
+		dev_err(&pdev->dev, "Failed to map interrupt\n");
+		ret = -ENXIO;
+		goto unmap_regs;
+	}
+
+	ret = request_irq(irq, cmn_pmu_irq_handler, IRQF_NOBALANCING | IRQF_NO_THREAD | IRQF_SHARED, "cmn_pmu_int", regs);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to request IRQ\n");
+		goto unmap_regs;
+	}
+	return 0;
+
+unmap_regs:
+	iounmap(regs);
+release_resource:
+	release_mem_region(res.start, res_size);
+	return ret;
+}
+
+static const struct of_device_id salina_cmn_pmu_irq_of_match[] = {
+	{ .compatible = "pensando,salina-cmn-pmu-interrupt" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, salina_cmn_pmu_irq_of_match);
+
+static struct platform_driver salina_cmn_pmu_irq = {
+	.probe = salina_cmn_pmu_irq_probe,
+	.driver = {
+		.name = "cmn_pmu_int",
+		.of_match_table = salina_cmn_pmu_irq_of_match,
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(salina_cmn_pmu_irq);
+
+MODULE_AUTHOR("Darshan Prajapati <darshan.prajapati@amd.com>");
+MODULE_DESCRIPTION("AMD Pensando Salina SoC CMN PMU IRQ Handler");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/pensando/kpcimgr.c b/drivers/soc/pensando/kpcimgr.c
index 81102cbe7222..9fced719bafc 100644
--- a/drivers/soc/pensando/kpcimgr.c
+++ b/drivers/soc/pensando/kpcimgr.c
@@ -22,6 +22,12 @@ kstate_t *kstate;
 DEFINE_SPINLOCK(kpcimgr_lock);
 static DECLARE_WAIT_QUEUE_HEAD(event_queue);
 
+void *kpci_memset(void *s, int c, size_t n);
+void kpcimgr_normal_poll(void);
+int contains_external_refs(struct module *mod, void *code_end);
+u64 kpcimgr_preg_read(u64 pa);
+unsigned long kpcimgr_get_entry(unsigned long old_entry, unsigned int cpu);
+
 void wake_up_event_queue(void)
 {
 	wake_up_interruptible(&event_queue);
@@ -382,7 +388,9 @@ int kpcimgr_module_register(struct module *mod,
 		}
 		kpci_memcpy(ks->code_base, mod->core_layout.base,
 			    mod->core_layout.size);
-		flush_icache_range((long)ks->code_base, (long)ks->code_base + mod->core_layout.size);
+		flush_icache_range((long)ks->code_base,
+				   (long)ks->code_base + mod->core_layout.size);
+
 		set_memory_x((unsigned long)ks->code_base,
 			     mod->core_layout.size >> PAGE_SHIFT);
 	} else {
@@ -549,7 +557,8 @@ static int map_resources(struct platform_device *pfdev)
 			}
 			kpci_memcpy(ks->code_base, ks->persistent_base,
 				    ks->code_size);
-			flush_icache_range((long)ks->code_base, (long)ks->code_base + KSTATE_CODE_SIZE);
+			flush_icache_range((long)ks->code_base,
+					   (long)ks->code_base + KSTATE_CODE_SIZE);
 			set_memory_x((unsigned long)ks->code_base,
 				     ks->code_size >> PAGE_SHIFT);
 		}
diff --git a/drivers/soc/pensando/kpcimgr_api.h b/drivers/soc/pensando/kpcimgr_api.h
index 07c821926160..6abf387a485b 100644
--- a/drivers/soc/pensando/kpcimgr_api.h
+++ b/drivers/soc/pensando/kpcimgr_api.h
@@ -7,6 +7,7 @@
 
 #ifdef __KERNEL__
 #include <linux/miscdevice.h>
+#include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/module.h>
 #include <linux/cdev.h>
diff --git a/drivers/soc/pensando/penfw.h b/drivers/soc/pensando/penfw.h
index 37ee4c0a88e2..fb6cfb772b7e 100644
--- a/drivers/soc/pensando/penfw.h
+++ b/drivers/soc/pensando/penfw.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (c) 2021, Pensando Systems Inc.
  */
@@ -18,6 +19,10 @@ enum penfw_opcodes {
 	PENFW_OP_GET_NEXT_LCS,
 	PENFW_OP_COMMIT_LCS_PROD,
 	PENFW_OP_GET_PENTRUST_VERSION,
+	PENFW_OP_GET_SERIAL_NUMBER,
+	PENFW_OP_GET_RANDOM,
+	PENFW_OP_GET_CHIP_CERT,
+	PENFW_OP_ATTEST_GET_TIME,
 	PENFW_OPCODE_MAX,
 };
 
@@ -26,8 +31,26 @@ struct penfw_call_args {
 	uint64_t a1;
 	uint64_t a2;
 	uint64_t a3;
+	uint64_t a4;
+	uint64_t a5;
 };
 
+#define PENFW_NONCE_LEN 12
+#define PENFW_EC_SIG_SZ 96
+
+struct penfw_time_attestation {
+	struct {
+		uint32_t magic;
+		uint8_t nonce[PENFW_NONCE_LEN];
+		uint64_t time;
+	} data;
+	struct {
+		uint8_t	r[PENFW_EC_SIG_SZ / 2];
+		uint8_t	s[PENFW_EC_SIG_SZ / 2];
+	} signature;
+};
+
+
 #define PENFW_IOCTL_NUM  0xcd
 #define PENFW_FWCALL     _IOWR(PENFW_IOCTL_NUM, 1, struct penfw_call_args)
 
diff --git a/drivers/soc/pensando/penfw_drv.c b/drivers/soc/pensando/penfw_drv.c
index e626ab95056e..8e13acf48dac 100644
--- a/drivers/soc/pensando/penfw_drv.c
+++ b/drivers/soc/pensando/penfw_drv.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (c) 2021, Pensando Systems Inc.
  */
@@ -25,6 +26,9 @@ static struct class *penfw_class;
 static struct device *penfw_dev;
 static DEFINE_MUTEX(penfw_mutex);
 
+void *penfwdata;
+phys_addr_t penfwdata_phys;
+
 static int penfw_open(struct inode *inodep, struct file *filep)
 {
 	return 0;
@@ -111,6 +115,16 @@ static int penfw_probe(struct platform_device *pdev)
 	}
 	dev_info(penfw_dev, "penfw sys initialization success\n");
 
+	// Allocate memory for smc calls
+	penfwdata = (struct penfw_data *)devm_get_free_pages(penfw_dev,
+									GFP_KERNEL | GFP_ATOMIC, 0);
+	if (penfwdata == NULL) {
+		dev_err(penfw_dev, "penfw memory allocation failed\n");
+		return -1;
+	}
+
+	penfwdata_phys = virt_to_phys(penfwdata);
+
 	return 0;
 }
 
@@ -127,7 +141,7 @@ static int penfw_remove(struct platform_device *pd)
 	return 0;
 }
 
-static const struct of_device_id penfw_of_match[] = {
+static struct of_device_id penfw_of_match[] = {
 	{ .compatible = "pensando,penfw" },
 	{ /* end of table */ }
 };
diff --git a/drivers/soc/pensando/penfw_smc.c b/drivers/soc/pensando/penfw_smc.c
index 94f10eab94a9..b923b285f3bb 100644
--- a/drivers/soc/pensando/penfw_smc.c
+++ b/drivers/soc/pensando/penfw_smc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (c) 2021, Pensando Systems Inc.
  */
@@ -6,11 +7,17 @@
 #include <linux/arm-smccc.h>
 #include <linux/printk.h>
 #include <linux/types.h>
+#include <linux/uaccess.h>
 
 #include "penfw.h"
 
 #define PENFW_CALL_FID			    0xC2000002
 
+extern void *penfwdata;
+extern phys_addr_t penfwdata_phys;
+void penfw_smc_get_chip_cert(struct penfw_call_args *args);
+void penfw_smc_attest_get_time(struct penfw_call_args *args);
+
 static const char *_opcode_to_str(uint8_t opcode)
 {
 	switch (opcode) {
@@ -36,28 +43,170 @@ static const char *_opcode_to_str(uint8_t opcode)
 		return "PENFW_OP_GET_NEXT_LCS";
 	case PENFW_OP_COMMIT_LCS_PROD:
 		return "PENFW_OP_COMMIT_LCS_PROD";
+	case PENFW_OP_GET_PENTRUST_VERSION:
+		return "PENFW_OP_GET_PENTRUST_VERSION";
+	case PENFW_OP_GET_SERIAL_NUMBER:
+		return "PENFW_OP_GET_SERIAL_NUMBER";
+	case PENFW_OP_GET_RANDOM:
+		return "PENFW_OP_GET_RANDOM";
+	case PENFW_OP_GET_CHIP_CERT:
+		return "PENFW_OP_GET_CHIP_CERT";
+	case PENFW_OP_ATTEST_GET_TIME:
+		return "PENFW_OP_ATTEST_GET_TIME";
 	default:
 		return "PENFW_OP_UNKNOWN";
 	}
 }
 
-void penfw_smc(struct penfw_call_args *args)
+/*
+ * a1 = smc op (PENFW_OP_GET_CHIP_CERT)
+ * a2 = user buffer pointer to save the cert
+ * a3 = length of the user buf to get the chip cert
+ */
+void penfw_smc_get_chip_cert(struct penfw_call_args *args)
 {
 	struct arm_smccc_res res = {0};
+	uint8_t *chip_cert = NULL;
+	phys_addr_t cert_phys = 0;
+	uint32_t cert_len = 0;
+	uint32_t user_cert_len = args->a3;
+	void __user *user_cert = (void __user *)args->a2;
 
-	pr_debug("penfw: smc call for fn: %s\n",
-		_opcode_to_str(args->a1));
+	if ((user_cert_len != 0) && (user_cert_len > PAGE_SIZE)) {
+		args->a0 = -1;
+		return;
+	}
+
+	chip_cert = (uint8_t *)penfwdata;
+	cert_phys = penfwdata_phys;
+
+	if (user_cert_len)
+		cert_len = PAGE_SIZE;
+
+	arm_smccc_smc(PENFW_CALL_FID, PENFW_OP_GET_CHIP_CERT, cert_phys,
+					cert_len, 0, 0, 0, 0, &res);
+
+	if (res.a1 > PAGE_SIZE) {
+		args->a0 = -1;
+		return;
+	}
+
+	if (user_cert_len) {
+		if (res.a1 > user_cert_len) {
+			args->a0 = -1;
+			return;
+		}
+		if (copy_to_user(user_cert, chip_cert, res.a1)) {
+			args->a0 = -1;
+			return;
+		}
+	}
+
+	/* zero-out chip-cert after copying to userspace */
+	memset(penfwdata, 0, PAGE_SIZE);
+
+	args->a0 = res.a0;
+	args->a1 = res.a1;
+	args->a2 = res.a2;
+}
+
+/*
+ * a1 = smc op (PENFW_OP_ATTEST_GET_TIME)
+ * a2 = pointer to user provided nonce.
+ * a3 = length of nonce (must be 12 bytes)
+ * a4 = pointer to user buffer for attestation data.
+ * a5 = length of user attestation buffer
+ */
+void penfw_smc_attest_get_time(struct penfw_call_args *args)
+{
+	struct penfw_time_attestation *attp;
+	struct arm_smccc_res res = {0};
+	void __user *user_ta = (void  __user *)args->a4;
+	uint8_t *nonce;
+	phys_addr_t nonce_phys = 0, att_phys;
+
+	nonce = (uint8_t *)penfwdata;
+	nonce_phys = penfwdata_phys;
+
+	attp = (struct penfw_time_attestation *)(penfwdata + PENFW_NONCE_LEN);
+	att_phys = penfwdata_phys + PENFW_NONCE_LEN;
+
+	if (args->a3 != PENFW_NONCE_LEN) {
+		args->a0 = -1;
+		return;
+	}
 
-	arm_smccc_smc(PENFW_CALL_FID, args->a1, args->a2, args->a3, 0, 0,
-		      0, 0, &res);
+	if (args->a5 < sizeof(struct penfw_time_attestation)) {
+		args->a0 = -1;
+		return;
+	}
+
+	if (copy_from_user(nonce, (void *)args->a2, PENFW_NONCE_LEN)) {
+		args->a0 = -1;
+		return;
+	}
+
+	arm_smccc_smc(PENFW_CALL_FID, PENFW_OP_ATTEST_GET_TIME,
+		(uint64_t)nonce_phys, PENFW_NONCE_LEN,
+		(uint64_t)att_phys, sizeof(*attp), 0, 0, &res);
+
+	if (res.a0 == 0) {
+		if (copy_to_user(user_ta, attp, sizeof(*attp))) {
+			args->a0 = -5;
+			return;
+		}
+	}
 
-	// copy return vals
 	args->a0 = res.a0;
 	args->a1 = res.a1;
 	args->a2 = res.a2;
 	args->a3 = res.a3;
 
-	pr_debug("penfw: smc return a0: 0x%llx a1: 0x%llx "
-		"a2: 0x%llx a3: 0x%llx\n", args->a0, args->a1,
-					   args->a2, args->a3);
+	/* zero out nonce and attestation data after copying to userspace */
+	memset(penfwdata, 0, PAGE_SIZE);
+}
+
+void penfw_smc(struct penfw_call_args *args)
+{
+	struct arm_smccc_res res = {0};
+
+	pr_debug("penfw: smc call for fn: %s\n",
+		 _opcode_to_str(args->a1));
+
+	switch (args->a1) {
+	case PENFW_OP_GET_API_VER:
+	case PENFW_OP_GET_PENTRUST_STA:
+	case PENFW_OP_SET_PENTRUST_UPG:
+	case PENFW_OP_GET_BL1_STA:
+	case PENFW_OP_SET_BL1_UPG:
+	case PENFW_OP_GET_BL1_AR_NVCNTR:
+	case PENFW_OP_COMMIT_BL1_AR_NVCNTR:
+	case PENFW_OP_GET_BL31_SW_VER:
+	case PENFW_OP_GET_BOOT_LCS:
+	case PENFW_OP_GET_NEXT_LCS:
+	case PENFW_OP_COMMIT_LCS_PROD:
+	case PENFW_OP_GET_PENTRUST_VERSION:
+	case PENFW_OP_GET_SERIAL_NUMBER:
+	case PENFW_OP_GET_RANDOM:
+		arm_smccc_smc(PENFW_CALL_FID, args->a1, args->a2, args->a3, 0, 0,
+						0, 0, &res);
+		// copy return vals
+		args->a0 = res.a0;
+		args->a1 = res.a1;
+		args->a2 = res.a2;
+		args->a3 = res.a3;
+		break;
+	case PENFW_OP_GET_CHIP_CERT:
+		penfw_smc_get_chip_cert(args);
+		break;
+	case PENFW_OP_ATTEST_GET_TIME:
+		penfw_smc_attest_get_time(args);
+		break;
+	default:
+		break;
+	}
+
+	pr_debug("penfw: smc return a0: 0x%llx a1: 0x%llx "\
+		 "a2: 0x%llx a3: 0x%llx\n", args->a0, args->a1,
+		 args->a2, args->a3);
 }
diff --git a/drivers/soc/pensando/penfw_sysfs.c b/drivers/soc/pensando/penfw_sysfs.c
index 1745c904737d..1e333240ad12 100644
--- a/drivers/soc/pensando/penfw_sysfs.c
+++ b/drivers/soc/pensando/penfw_sysfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (c) 2021, Pensando Systems Inc.
  */
@@ -10,6 +11,7 @@
 #include <linux/device.h>
 #include <linux/types.h>
 #include <linux/string.h>
+#include <linux/module.h>
 
 #include "penfw_sysfs.h"
 #include "penfw.h"
@@ -44,8 +46,8 @@ static ssize_t pentrust_show(struct kobject *kobj, struct kobj_attribute *attr,
 		return sprintf(buf, "\n");
 }
 
-static ssize_t pentrust_show_version(struct kobject *kobj, struct kobj_attribute *attr,
-			     char *buf)
+static ssize_t pentrust_show_version(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
 {
 	struct penfw_call_args args = {0};
 	int major, minor1, minor2;
@@ -66,8 +68,9 @@ static ssize_t pentrust_show_version(struct kobject *kobj, struct kobj_attribute
 		minor1 = (args.a2 & 0xffff0000) >> 16;
 		minor2 = args.a2 & 0xffff;
 		return sprintf(buf, "%d.%d.%d\n", major, minor1, minor2);
-	} else
+	} else {
 		return sprintf(buf, "\n");
+	}
 }
 
 static ssize_t pentrust_store(struct kobject *kobj, struct kobj_attribute *attr,
@@ -77,6 +80,7 @@ static ssize_t pentrust_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 	if (strcmp(attr->attr.name, "upgrade") != 0)
 		return -1;
+
 	args.a1 = PENFW_OP_SET_PENTRUST_UPG;
 	penfw_smc(&args);
 	if (args.a0 < 0)
@@ -132,6 +136,7 @@ static ssize_t bl1_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 	if (strcmp(attr->attr.name, "upgrade") != 0)
 		return -1;
+
 	args.a1 = PENFW_OP_SET_BL1_UPG;
 	penfw_smc(&args);
 	if (args.a0 < 0)
diff --git a/drivers/soc/pensando/penfw_sysfs.h b/drivers/soc/pensando/penfw_sysfs.h
index 46eb644256c1..41debed5fd65 100644
--- a/drivers/soc/pensando/penfw_sysfs.h
+++ b/drivers/soc/pensando/penfw_sysfs.h
@@ -1,7 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (c) 2021, Pensando Systems Inc.
  */
-
 #ifndef __PENFW_SYSFS_H__
 #define __PENFW_SYSFS_H__
 
diff --git a/drivers/soc/pensando/sbus.c b/drivers/soc/pensando/sbus.c
index 2940f8c6825a..c97ba84db12b 100644
--- a/drivers/soc/pensando/sbus.c
+++ b/drivers/soc/pensando/sbus.c
@@ -17,6 +17,7 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
+#include <linux/platform_device.h>
 #include <linux/delay.h>
 
 #define MAX_DEVICES			4
@@ -26,9 +27,9 @@
 #define SBUS_INDIR_DATA_ADDR_LSB	8
 #define SBUS_INDIR_DATA_COMMAND_LSB	16
 
-static dev_t sbus_dev = 0;
+static dev_t sbus_dev;
 static struct class *dev_class;
-static int dev_inst = 0;
+static int dev_inst;
 
 struct sbus_ioctl_args {
 	u32 sbus_rcvr_addr;
@@ -59,7 +60,7 @@ static int sbus_drv_open(struct inode *inode, struct file *file)
 }
 
 static void sbus_write(struct sbus_ioctl_args param,
-				struct sbusdev_info *sbus_ring)
+		       struct sbusdev_info *sbus_ring)
 {
 	uint32_t sbus_val;
 
@@ -79,7 +80,7 @@ static void sbus_write(struct sbus_ioctl_args param,
 }
 
 static uint32_t sbus_read(struct sbus_ioctl_args param,
-				struct sbusdev_info * sbus_ring)
+			  struct sbusdev_info *sbus_ring)
 {
 	uint32_t sbus_val, val;
 
@@ -101,7 +102,7 @@ static uint32_t sbus_read(struct sbus_ioctl_args param,
 }
 
 static void sbus_reset(struct sbus_ioctl_args param,
-		struct sbusdev_info *sbus_ring)
+		       struct sbusdev_info *sbus_ring)
 {
 	uint32_t sbus_val;
 
@@ -124,7 +125,7 @@ static void sbus_reset(struct sbus_ioctl_args param,
  * This function will be called when we write IOCTL on the Device file
  */
 static long sbus_drv_ioctl(struct file *file, unsigned int cmd,
-			unsigned long arg)
+			   unsigned long arg)
 {
 	struct sbusdev_info *sbus_ring = file->private_data;
 	struct sbus_ioctl_args param_ioctl;
@@ -161,7 +162,6 @@ static long sbus_drv_ioctl(struct file *file, unsigned int cmd,
 		break;
 	default:
 		return -ENOTTY;
-		break;
 	}
 
 	return 0;
@@ -170,7 +170,7 @@ static long sbus_drv_ioctl(struct file *file, unsigned int cmd,
 /*
  * File operation structure
  */
-static struct file_operations fops = {
+static const struct file_operations fops = {
 	.open = sbus_drv_open,
 	.owner = THIS_MODULE,
 	.unlocked_ioctl = sbus_drv_ioctl,
@@ -224,11 +224,11 @@ static int sbus_probe(struct platform_device *pdev)
 			return -1;
 		}
 		pr_debug("Major = %d Minor = %d \n", MAJOR(sbus_dev),
-				MINOR(sbus_dev));
+			MINOR(sbus_dev));
 
 		/* Creating struct class */
-		if ((dev_class =
-			class_create(THIS_MODULE, "sbus_class")) == NULL) {
+		dev_class = class_create(THIS_MODULE, "sbus_class");
+		if (dev_class == NULL) {
 			pr_err("Cannot create the struct class\n");
 			goto r_class;
 		}
-- 
2.25.1

